// Code generated by engine.go; DO NOT EDIT.

package provider

import (
	"k8s.io/kops/pkg/apis/kops"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

func expandBool(in interface{}) *bool {
	out := in.(*bool)

	return out
}

func expandFileAssetSpecSlice(in interface{}) []kops.FileAssetSpec {
	d := in.([]interface{})
	out := make([]kops.FileAssetSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.FileAssetSpec{}

		if v, ok := d[i].(map[string]interface{})["content"]; ok {
			out[i].Content = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["is_base_64"]; ok {
			value := expandBool(v)

			out[i].IsBase64 = (*value)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["path"]; ok {
			out[i].Path = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["roles"]; ok {
			out[i].Roles = expandInstanceGroupRoleSlice(v)
		}
	}

	return out
}

func expandHookSpecSlice(in interface{}) []kops.HookSpec {
	d := in.([]interface{})
	out := make([]kops.HookSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.HookSpec{}

		if v, ok := d[i].(map[string]interface{})["before"]; ok {
			out[i].Before = expandStringSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["disabled"]; ok {
			value := expandBool(v)

			out[i].Disabled = (*value)
		}

		if v, ok := d[i].(map[string]interface{})["exec_container"]; ok {
			out[i].ExecContainer = expandExecContainerAction(v)
		}

		if v, ok := d[i].(map[string]interface{})["manifest"]; ok {
			out[i].Manifest = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["requires"]; ok {
			out[i].Requires = expandStringSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["roles"]; ok {
			out[i].Roles = expandInstanceGroupRoleSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["use_raw_manifest"]; ok {
			value := expandBool(v)

			out[i].UseRawManifest = (*value)
		}
	}

	return out
}

func expandInitializers(in interface{}) *v1.Initializers {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &v1.Initializers{}

	{
		out.Pending = expandInitializerSlice(d["pending"])
	}

	if v, ok := d["result"]; ok {
		out.Result = expandStatus(v)
	}

	return out
}

func expandInt32(in interface{}) int32 {
	out := in.(int32)

	return out
}

func expandInt64(in interface{}) int64 {
	out := in.(int64)

	return out
}

func expandKubeletConfigSpec(in interface{}) *kops.KubeletConfigSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeletConfigSpec{}

	if v, ok := d["api_servers"]; ok {
		out.APIServers = expandString(v)
	}

	if v, ok := d["allow_privileged"]; ok {
		out.AllowPrivileged = expandBool(v)
	}

	if v, ok := d["allowed_unsafe_sysctls"]; ok {
		out.AllowedUnsafeSysctls = expandStringSlice(v)
	}

	if v, ok := d["anonymous_auth"]; ok {
		out.AnonymousAuth = expandBool(v)
	}

	if v, ok := d["authentication_token_webhook"]; ok {
		out.AuthenticationTokenWebhook = expandBool(v)
	}

	if v, ok := d["authentication_token_webhook_cache_ttl"]; ok {
		out.AuthenticationTokenWebhookCacheTTL = expandDuration(v)
	}

	if v, ok := d["authorization_mode"]; ok {
		out.AuthorizationMode = expandString(v)
	}

	if v, ok := d["babysit_daemons"]; ok {
		out.BabysitDaemons = expandBool(v)
	}

	if v, ok := d["bootstrap_kubeconfig"]; ok {
		out.BootstrapKubeconfig = expandString(v)
	}

	if v, ok := d["cpu_cfs_quota"]; ok {
		out.CPUCFSQuota = expandBool(v)
	}

	if v, ok := d["cpu_cfs_quota_period"]; ok {
		out.CPUCFSQuotaPeriod = expandDuration(v)
	}

	if v, ok := d["cgroup_root"]; ok {
		out.CgroupRoot = expandString(v)
	}

	if v, ok := d["client_ca_file"]; ok {
		out.ClientCAFile = expandString(v)
	}

	if v, ok := d["cloud_provider"]; ok {
		out.CloudProvider = expandString(v)
	}

	if v, ok := d["cluster_dns"]; ok {
		out.ClusterDNS = expandString(v)
	}

	if v, ok := d["cluster_domain"]; ok {
		out.ClusterDomain = expandString(v)
	}

	if v, ok := d["configure_cbr_0"]; ok {
		out.ConfigureCBR0 = expandBool(v)
	}

	if v, ok := d["cpu_manager_policy"]; ok {
		out.CpuManagerPolicy = expandString(v)
	}

	if v, ok := d["docker_disable_shared_pid"]; ok {
		out.DockerDisableSharedPID = expandBool(v)
	}

	if v, ok := d["enable_custom_metrics"]; ok {
		out.EnableCustomMetrics = expandBool(v)
	}

	if v, ok := d["enable_debugging_handlers"]; ok {
		out.EnableDebuggingHandlers = expandBool(v)
	}

	if v, ok := d["enforce_node_allocatable"]; ok {
		out.EnforceNodeAllocatable = expandString(v)
	}

	if v, ok := d["eviction_hard"]; ok {
		value := expandString(v)

		out.EvictionHard = &value
	}

	if v, ok := d["eviction_max_pod_grace_period"]; ok {
		out.EvictionMaxPodGracePeriod = expandInt32(v)
	}

	if v, ok := d["eviction_minimum_reclaim"]; ok {
		out.EvictionMinimumReclaim = expandString(v)
	}

	if v, ok := d["eviction_pressure_transition_period"]; ok {
		out.EvictionPressureTransitionPeriod = expandDuration(v)
	}

	if v, ok := d["eviction_soft"]; ok {
		out.EvictionSoft = expandString(v)
	}

	if v, ok := d["eviction_soft_grace_period"]; ok {
		out.EvictionSoftGracePeriod = expandString(v)
	}

	if v, ok := d["experimental_allowed_unsafe_sysctls"]; ok {
		out.ExperimentalAllowedUnsafeSysctls = expandStringSlice(v)
	}

	if v, ok := d["fail_swap_on"]; ok {
		out.FailSwapOn = expandBool(v)
	}

	if v, ok := d["feature_gates"]; ok {
		out.FeatureGates = expandStringMap(v)
	}

	if v, ok := d["hairpin_mode"]; ok {
		out.HairpinMode = expandString(v)
	}

	if v, ok := d["hostname_override"]; ok {
		out.HostnameOverride = expandString(v)
	}

	if v, ok := d["image_gc_high_threshold_percent"]; ok {
		value := expandInt32(v)

		out.ImageGCHighThresholdPercent = &value
	}

	if v, ok := d["image_gc_low_threshold_percent"]; ok {
		value := expandInt32(v)

		out.ImageGCLowThresholdPercent = &value
	}

	if v, ok := d["image_pull_progress_deadline"]; ok {
		out.ImagePullProgressDeadline = expandDuration(v)
	}

	if v, ok := d["kube_reserved"]; ok {
		out.KubeReserved = expandStringMap(v)
	}

	if v, ok := d["kube_reserved_cgroup"]; ok {
		out.KubeReservedCgroup = expandString(v)
	}

	if v, ok := d["kubeconfig_path"]; ok {
		out.KubeconfigPath = expandString(v)
	}

	if v, ok := d["kubelet_cgroups"]; ok {
		out.KubeletCgroups = expandString(v)
	}

	if v, ok := d["log_level"]; ok {
		value := expandInt32(v)

		out.LogLevel = &value
	}

	if v, ok := d["max_pods"]; ok {
		value := expandInt32(v)

		out.MaxPods = &value
	}

	if v, ok := d["network_plugin_mtu"]; ok {
		value := expandInt32(v)

		out.NetworkPluginMTU = &value
	}

	if v, ok := d["network_plugin_name"]; ok {
		out.NetworkPluginName = expandString(v)
	}

	if v, ok := d["node_labels"]; ok {
		out.NodeLabels = expandStringMap(v)
	}

	if v, ok := d["node_status_update_frequency"]; ok {
		out.NodeStatusUpdateFrequency = expandDuration(v)
	}

	if v, ok := d["non_masquerade_cidr"]; ok {
		out.NonMasqueradeCIDR = expandString(v)
	}

	if v, ok := d["nvidia_gp_uss"]; ok {
		out.NvidiaGPUs = expandInt32(v)
	}

	if v, ok := d["pod_cidr"]; ok {
		out.PodCIDR = expandString(v)
	}

	if v, ok := d["pod_infra_container_image"]; ok {
		out.PodInfraContainerImage = expandString(v)
	}

	if v, ok := d["pod_manifest_path"]; ok {
		out.PodManifestPath = expandString(v)
	}

	if v, ok := d["read_only_port"]; ok {
		value := expandInt32(v)

		out.ReadOnlyPort = &value
	}

	if v, ok := d["reconcile_cidr"]; ok {
		out.ReconcileCIDR = expandBool(v)
	}

	if v, ok := d["register_node"]; ok {
		out.RegisterNode = expandBool(v)
	}

	if v, ok := d["register_schedulable"]; ok {
		out.RegisterSchedulable = expandBool(v)
	}

	if v, ok := d["registry_burst"]; ok {
		value := expandInt32(v)

		out.RegistryBurst = &value
	}

	if v, ok := d["registry_pull_qps"]; ok {
		value := expandInt32(v)

		out.RegistryPullQPS = &value
	}

	if v, ok := d["require_kubeconfig"]; ok {
		out.RequireKubeconfig = expandBool(v)
	}

	if v, ok := d["resolv_conf"]; ok {
		value := expandString(v)

		out.ResolverConfig = &value
	}

	if v, ok := d["root_dir"]; ok {
		out.RootDir = expandString(v)
	}

	if v, ok := d["runtime_cgroups"]; ok {
		out.RuntimeCgroups = expandString(v)
	}

	if v, ok := d["runtime_request_timeout"]; ok {
		out.RuntimeRequestTimeout = expandDuration(v)
	}

	if v, ok := d["seccomp_profile_root"]; ok {
		value := expandString(v)

		out.SeccompProfileRoot = &value
	}

	if v, ok := d["serialize_image_pulls"]; ok {
		out.SerializeImagePulls = expandBool(v)
	}

	if v, ok := d["streaming_connection_idle_timeout"]; ok {
		out.StreamingConnectionIdleTimeout = expandDuration(v)
	}

	if v, ok := d["system_cgroups"]; ok {
		out.SystemCgroups = expandString(v)
	}

	if v, ok := d["system_reserved"]; ok {
		out.SystemReserved = expandStringMap(v)
	}

	if v, ok := d["system_reserved_cgroup"]; ok {
		out.SystemReservedCgroup = expandString(v)
	}

	if v, ok := d["tls_cert_file"]; ok {
		out.TLSCertFile = expandString(v)
	}

	if v, ok := d["tls_cipher_suites"]; ok {
		out.TLSCipherSuites = expandStringSlice(v)
	}

	if v, ok := d["tls_min_version"]; ok {
		out.TLSMinVersion = expandString(v)
	}

	if v, ok := d["tls_private_key_file"]; ok {
		out.TLSPrivateKeyFile = expandString(v)
	}

	if v, ok := d["taints"]; ok {
		out.Taints = expandStringSlice(v)
	}

	if v, ok := d["volume_plugin_directory"]; ok {
		out.VolumePluginDirectory = expandString(v)
	}

	if v, ok := d["volume_stats_agg_period"]; ok {
		out.VolumeStatsAggPeriod = expandDuration(v)
	}

	return out
}

func expandManagedFieldsEntrySlice(in interface{}) []v1.ManagedFieldsEntry {
	d := in.([]interface{})
	out := make([]v1.ManagedFieldsEntry , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = v1.ManagedFieldsEntry{}

		if v, ok := d[i].(map[string]interface{})["api_version"]; ok {
			out[i].APIVersion = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["fields"]; ok {
			out[i].Fields = expandFields(v)
		}

		if v, ok := d[i].(map[string]interface{})["manager"]; ok {
			out[i].Manager = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["operation"]; ok {
			out[i].Operation = expandManagedFieldsOperationType(v)
		}

		if v, ok := d[i].(map[string]interface{})["time"]; ok {
			value := expandTime(v)

			out[i].Time = &value
		}
	}

	return out
}

func expandObjectMeta(in interface{}) v1.ObjectMeta {
	d := in.([]interface{})[0].(map[string]interface{})
	out := v1.ObjectMeta{}

	if v, ok := d["annotations"]; ok {
		out.Annotations = expandStringMap(v)
	}

	if v, ok := d["cluster_name"]; ok {
		out.ClusterName = expandString(v)
	}

	if v, ok := d["creation_timestamp"]; ok {
		out.CreationTimestamp = expandTime(v)
	}

	if v, ok := d["deletion_grace_period_seconds"]; ok {
		value := expandInt64(v)

		out.DeletionGracePeriodSeconds = &value
	}

	if v, ok := d["deletion_timestamp"]; ok {
		value := expandTime(v)

		out.DeletionTimestamp = &value
	}

	if v, ok := d["finalizers"]; ok {
		out.Finalizers = expandStringSlice(v)
	}

	if v, ok := d["generate_name"]; ok {
		out.GenerateName = expandString(v)
	}

	if v, ok := d["generation"]; ok {
		out.Generation = expandInt64(v)
	}

	if v, ok := d["initializers"]; ok {
		out.Initializers = expandInitializers(v)
	}

	if v, ok := d["labels"]; ok {
		out.Labels = expandStringMap(v)
	}

	if v, ok := d["managed_fields"]; ok {
		out.ManagedFields = expandManagedFieldsEntrySlice(v)
	}

	if v, ok := d["name"]; ok {
		out.Name = expandString(v)
	}

	if v, ok := d["namespace"]; ok {
		out.Namespace = expandString(v)
	}

	if v, ok := d["owner_references"]; ok {
		out.OwnerReferences = expandOwnerReferenceSlice(v)
	}

	if v, ok := d["resource_version"]; ok {
		out.ResourceVersion = expandString(v)
	}

	if v, ok := d["self_link"]; ok {
		out.SelfLink = expandString(v)
	}

	if v, ok := d["uid"]; ok {
		out.UID = expandUID(v)
	}

	return out
}

func expandOwnerReferenceSlice(in interface{}) []v1.OwnerReference {
	d := in.([]interface{})
	out := make([]v1.OwnerReference , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = v1.OwnerReference{}

		if v, ok := d[i].(map[string]interface{})["api_version"]; ok {
			out[i].APIVersion = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["block_owner_deletion"]; ok {
			out[i].BlockOwnerDeletion = expandBool(v)
		}

		if v, ok := d[i].(map[string]interface{})["controller"]; ok {
			out[i].Controller = expandBool(v)
		}

		if v, ok := d[i].(map[string]interface{})["kind"]; ok {
			out[i].Kind = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["uid"]; ok {
			out[i].UID = expandUID(v)
		}
	}

	return out
}

func expandString(in interface{}) string {
	out := in.(string)

	return out
}

func expandStringMap(in interface{}) map[string]string {
	out := in.(map[string]string)

	return out
}

func expandStringSlice(in interface{}) []string {
	d := in.([]interface{})
	out := make([]string , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = d[i].(string)
	}

	return out
}

func expandTypeMeta(in interface{}) v1.TypeMeta {
	d := in.([]interface{})[0].(map[string]interface{})
	out := v1.TypeMeta{}

	if v, ok := d["api_version"]; ok {
		out.APIVersion = expandString(v)
	}

	if v, ok := d["kind"]; ok {
		out.Kind = expandString(v)
	}

	return out
}

func expandUID(in interface{}) types.UID {
	out := in.(types.UID)

	return out
}
