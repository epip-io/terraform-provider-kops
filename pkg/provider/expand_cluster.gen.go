// Code generated by engine.go; DO NOT EDIT.

package provider

import (
	"k8s.io/kops/pkg/apis/kops"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/api/resource"
)

func expandAccessSpec(in interface{}) (kops.AccessSpec, bool) {
	d := in.([]interface{})
	out := kops.AccessSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["dns"]; ok {
		if value, e := expandDNSAccessSpec(v); !e {
      out.DNS = &value
    }
	}

	if v, ok := m["load_balancer"]; ok {
		if value, e := expandLoadBalancerAccessSpec(v); !e {
      out.LoadBalancer = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandAddonSpecSlice(in interface{}) ([]kops.AddonSpec, bool) {
	d := in.([]interface{})
	out := make([]kops.AddonSpec , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = kops.AddonSpec{}

		if v, ok := d[i].(map[string]interface{})["manifest"]; ok {
      if value, e := expandString(v); !e {
        out[i].Manifest = value
      }
		}
	}

	return out, false
}

func expandAlwaysAllowAuthorizationSpec(in interface{}) (kops.AlwaysAllowAuthorizationSpec, bool) {
	out := kops.AlwaysAllowAuthorizationSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandAmazonVPCNetworkingSpec(in interface{}) (kops.AmazonVPCNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.AmazonVPCNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["image_name"]; ok {
		if value, e := expandString(v); !e {
      out.ImageName = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandAssets(in interface{}) (kops.Assets, bool) {
	d := in.([]interface{})
	out := kops.Assets{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["container_proxy"]; ok {
		if value, e := expandString(v); !e {
      out.ContainerProxy = &value
    }
	}

	if v, ok := m["container_registry"]; ok {
		if value, e := expandString(v); !e {
      out.ContainerRegistry = &value
    }
	}

	if v, ok := m["file_repository"]; ok {
		if value, e := expandString(v); !e {
      out.FileRepository = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandAuthenticationSpec(in interface{}) (kops.AuthenticationSpec, bool) {
	d := in.([]interface{})
	out := kops.AuthenticationSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["aws"]; ok {
		if value, e := expandAwsAuthenticationSpec(v); !e {
      out.Aws = &value
    }
	}

	if v, ok := m["kopeio"]; ok {
		if value, e := expandKopeioAuthenticationSpec(v); !e {
      out.Kopeio = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandAuthorizationSpec(in interface{}) (kops.AuthorizationSpec, bool) {
	d := in.([]interface{})
	out := kops.AuthorizationSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["always_allow"]; ok {
		if value, e := expandAlwaysAllowAuthorizationSpec(v); !e {
      out.AlwaysAllow = &value
    }
	}

	if v, ok := m["rbac"]; ok {
		if value, e := expandRBACAuthorizationSpec(v); !e {
      out.RBAC = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandAwsAuthenticationSpec(in interface{}) (kops.AwsAuthenticationSpec, bool) {
	d := in.([]interface{})
	out := kops.AwsAuthenticationSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["cpu_limit"]; ok {
		if value, e := expandQuantity(v); !e {
      out.CPULimit = &value
    }
	}

	if v, ok := m["cpu_request"]; ok {
		if value, e := expandQuantity(v); !e {
      out.CPURequest = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["memory_limit"]; ok {
		if value, e := expandQuantity(v); !e {
      out.MemoryLimit = &value
    }
	}

	if v, ok := m["memory_request"]; ok {
		if value, e := expandQuantity(v); !e {
      out.MemoryRequest = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandBastionSpec(in interface{}) (kops.BastionSpec, bool) {
	d := in.([]interface{})
	out := kops.BastionSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["bastion_public_name"]; ok {
		if value, e := expandString(v); !e {
      out.BastionPublicName = value
    }
	}

	if v, ok := m["idle_timeout_seconds"]; ok {
		if value, e := expandInt64(v); !e {
      out.IdleTimeoutSeconds = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandCNINetworkingSpec(in interface{}) (kops.CNINetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.CNINetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["uses_secondary_ip"]; ok {
		if value, e := expandBool(v); !e {
      out.UsesSecondaryIP = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandCalicoNetworkingSpec(in interface{}) (kops.CalicoNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.CalicoNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["cross_subnet"]; ok {
		if value, e := expandBool(v); !e {
      out.CrossSubnet = value
    }
	}

	if v, ok := m["ipip_mode"]; ok {
		if value, e := expandString(v); !e {
      out.IPIPMode = value
    }
	}

	if v, ok := m["log_severity_screen"]; ok {
		if value, e := expandString(v); !e {
      out.LogSeverityScreen = value
    }
	}

	if v, ok := m["mtu"]; ok {
		if value, e := expandInt32(v); !e {
      out.MTU = &value
    }
	}

	if v, ok := m["major_version"]; ok {
		if value, e := expandString(v); !e {
      out.MajorVersion = value
    }
	}

	if v, ok := m["prometheus_go_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusGoMetricsEnabled = value
    }
	}

	if v, ok := m["prometheus_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusMetricsEnabled = value
    }
	}

	if v, ok := m["prometheus_metrics_port"]; ok {
		if value, e := expandInt32(v); !e {
      out.PrometheusMetricsPort = value
    }
	}

	if v, ok := m["prometheus_process_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusProcessMetricsEnabled = value
    }
	}

	if v, ok := m["typha_prometheus_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.TyphaPrometheusMetricsEnabled = value
    }
	}

	if v, ok := m["typha_prometheus_metrics_port"]; ok {
		if value, e := expandInt32(v); !e {
      out.TyphaPrometheusMetricsPort = value
    }
	}

	if v, ok := m["typha_replicas"]; ok {
		if value, e := expandInt32(v); !e {
      out.TyphaReplicas = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandCanalNetworkingSpec(in interface{}) (kops.CanalNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.CanalNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["chain_insert_mode"]; ok {
		if value, e := expandString(v); !e {
      out.ChainInsertMode = value
    }
	}

	if v, ok := m["default_endpoint_to_host_action"]; ok {
		if value, e := expandString(v); !e {
      out.DefaultEndpointToHostAction = value
    }
	}

	if v, ok := m["disable_flannel_forward_rules"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableFlannelForwardRules = value
    }
	}

	if v, ok := m["log_severity_sys"]; ok {
		if value, e := expandString(v); !e {
      out.LogSeveritySys = value
    }
	}

	if v, ok := m["mtu"]; ok {
		if value, e := expandInt32(v); !e {
      out.MTU = &value
    }
	}

	if v, ok := m["prometheus_go_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusGoMetricsEnabled = value
    }
	}

	if v, ok := m["prometheus_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusMetricsEnabled = value
    }
	}

	if v, ok := m["prometheus_metrics_port"]; ok {
		if value, e := expandInt32(v); !e {
      out.PrometheusMetricsPort = value
    }
	}

	if v, ok := m["prometheus_process_metrics_enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.PrometheusProcessMetricsEnabled = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandCauseType(in interface{}) (v1.CauseType, bool) {
	d := in.(string)
	r := v1.CauseType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandCiliumNetworkingSpec(in interface{}) (kops.CiliumNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.CiliumNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["access_log"]; ok {
		if value, e := expandString(v); !e {
      out.AccessLog = value
    }
	}

	if v, ok := m["agent_labels"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AgentLabels = value
    }
	}

	if v, ok := m["allow_localhost"]; ok {
		if value, e := expandString(v); !e {
      out.AllowLocalhost = value
    }
	}

	{
		if value, e := expandBool(m["auto_direct_node_routes"]); !e {
      out.AutoDirectNodeRoutes = value
    }
	}

	if v, ok := m["auto_ipv_6node_routes"]; ok {
		if value, e := expandBool(v); !e {
      out.AutoIpv6NodeRoutes = value
    }
	}

	{
		if value, e := expandInt(m["bpf_ct_global_any_max"]); !e {
      out.BPFCTGlobalAnyMax = value
    }
	}

	{
		if value, e := expandInt(m["bpf_ct_global_tcp_max"]); !e {
      out.BPFCTGlobalTCPMax = value
    }
	}

	if v, ok := m["bpf_root"]; ok {
		if value, e := expandString(v); !e {
      out.BPFRoot = value
    }
	}

	{
		if value, e := expandString(m["cluster_name"]); !e {
      out.ClusterName = value
    }
	}

	{
		if value, e := expandString(m["cni_bin_path"]); !e {
      out.CniBinPath = value
    }
	}

	if v, ok := m["container_runtime"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.ContainerRuntime = value
    }
	}

	if v, ok := m["container_runtime_endpoint"]; ok {
		if value, e := expandStringMap(v); !e {
      out.ContainerRuntimeEndpoint = value
    }
	}

	if v, ok := m["container_runtime_labels"]; ok {
		if value, e := expandString(v); !e {
      out.ContainerRuntimeLabels = value
    }
	}

	if v, ok := m["debug"]; ok {
		if value, e := expandBool(v); !e {
      out.Debug = value
    }
	}

	if v, ok := m["debug_verbose"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.DebugVerbose = value
    }
	}

	if v, ok := m["device"]; ok {
		if value, e := expandString(v); !e {
      out.Device = value
    }
	}

	if v, ok := m["disable_conntrack"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableConntrack = value
    }
	}

	if v, ok := m["disable_ipv_4"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableIpv4 = value
    }
	}

	if v, ok := m["disable_k8s_services"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableK8sServices = value
    }
	}

	if v, ok := m["disable_masquerade"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableMasquerade = value
    }
	}

	{
		if value, e := expandBool(m["enableipv_4"]); !e {
      out.EnableIpv4 = value
    }
	}

	{
		if value, e := expandBool(m["enableipv_6"]); !e {
      out.EnableIpv6 = value
    }
	}

	{
		if value, e := expandBool(m["enable_node_port"]); !e {
      out.EnableNodePort = value
    }
	}

	if v, ok := m["enable_policy"]; ok {
		if value, e := expandString(v); !e {
      out.EnablePolicy = value
    }
	}

	if v, ok := m["enable_tracing"]; ok {
		if value, e := expandBool(v); !e {
      out.EnableTracing = value
    }
	}

	if v, ok := m["envoy_log"]; ok {
		if value, e := expandString(v); !e {
      out.EnvoyLog = value
    }
	}

	{
		if value, e := expandBool(m["ip_tables_rules_noinstall"]); !e {
      out.IPTablesRulesNoinstall = value
    }
	}

	if v, ok := m["ipv_4cluster_cidr_mask_size"]; ok {
		if value, e := expandInt(v); !e {
      out.Ipv4ClusterCIDRMaskSize = value
    }
	}

	if v, ok := m["ipv_4node"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv4Node = value
    }
	}

	if v, ok := m["ipv_4range"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv4Range = value
    }
	}

	if v, ok := m["ipv_4service_range"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv4ServiceRange = value
    }
	}

	if v, ok := m["ipv_6cluster_alloc_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv6ClusterAllocCidr = value
    }
	}

	if v, ok := m["ipv_6node"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv6Node = value
    }
	}

	if v, ok := m["ipv_6range"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv6Range = value
    }
	}

	if v, ok := m["ipv_6service_range"]; ok {
		if value, e := expandString(v); !e {
      out.Ipv6ServiceRange = value
    }
	}

	if v, ok := m["k_8s_api_server"]; ok {
		if value, e := expandString(v); !e {
      out.K8sAPIServer = value
    }
	}

	if v, ok := m["k_8s_kubeconfig_path"]; ok {
		if value, e := expandString(v); !e {
      out.K8sKubeconfigPath = value
    }
	}

	if v, ok := m["keep_bpf_templates"]; ok {
		if value, e := expandBool(v); !e {
      out.KeepBPFTemplates = value
    }
	}

	if v, ok := m["keep_config"]; ok {
		if value, e := expandBool(v); !e {
      out.KeepConfig = value
    }
	}

	if v, ok := m["lb"]; ok {
		if value, e := expandString(v); !e {
      out.LB = value
    }
	}

	if v, ok := m["label_prefix_file"]; ok {
		if value, e := expandString(v); !e {
      out.LabelPrefixFile = value
    }
	}

	if v, ok := m["labels"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.Labels = value
    }
	}

	if v, ok := m["lib_dir"]; ok {
		if value, e := expandString(v); !e {
      out.LibDir = value
    }
	}

	if v, ok := m["log_driver"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.LogDrivers = value
    }
	}

	if v, ok := m["log_opt"]; ok {
		if value, e := expandStringMap(v); !e {
      out.LogOpt = value
    }
	}

	if v, ok := m["logstash"]; ok {
		if value, e := expandBool(v); !e {
      out.Logstash = value
    }
	}

	if v, ok := m["logstash_agent"]; ok {
		if value, e := expandString(v); !e {
      out.LogstashAgent = value
    }
	}

	if v, ok := m["logstash_probe_timer"]; ok {
		if value, e := expandUint32(v); !e {
      out.LogstashProbeTimer = value
    }
	}

	{
		if value, e := expandString(m["monitor_aggregation"]); !e {
      out.MonitorAggregation = value
    }
	}

	if v, ok := m["nat_46range"]; ok {
		if value, e := expandString(v); !e {
      out.Nat46Range = value
    }
	}

	{
		if value, e := expandString(m["node_init_bootstrap_file"]); !e {
      out.NodeInitBootstrapFile = value
    }
	}

	if v, ok := m["pprof"]; ok {
		if value, e := expandBool(v); !e {
      out.Pprof = value
    }
	}

	{
		if value, e := expandBool(m["preallocate_bpf_maps"]); !e {
      out.PreallocateBPFMaps = value
    }
	}

	if v, ok := m["prefilter_device"]; ok {
		if value, e := expandString(v); !e {
      out.PrefilterDevice = value
    }
	}

	if v, ok := m["prometheus_serve_addr"]; ok {
		if value, e := expandString(v); !e {
      out.PrometheusServeAddr = value
    }
	}

	{
		if value, e := expandBool(m["reconfigure_kubelet"]); !e {
      out.ReconfigureKubelet = value
    }
	}

	{
		if value, e := expandBool(m["remove_cbr_bridge"]); !e {
      out.RemoveCbrBridge = value
    }
	}

	{
		if value, e := expandBool(m["restart_pods"]); !e {
      out.RestartPods = value
    }
	}

	if v, ok := m["restore"]; ok {
		if value, e := expandBool(v); !e {
      out.Restore = value
    }
	}

	{
		if value, e := expandString(m["sidecar_istio_proxy_image"]); !e {
      out.SidecarIstioProxyImage = value
    }
	}

	if v, ok := m["single_cluster_route"]; ok {
		if value, e := expandBool(v); !e {
      out.SingleClusterRoute = value
    }
	}

	if v, ok := m["socket_path"]; ok {
		if value, e := expandString(v); !e {
      out.SocketPath = value
    }
	}

	if v, ok := m["state_dir"]; ok {
		if value, e := expandString(v); !e {
      out.StateDir = value
    }
	}

	{
		if value, e := expandBool(m["to_fqdns_enable_poller"]); !e {
      out.ToFqdnsEnablePoller = value
    }
	}

	if v, ok := m["trace_payloadlen"]; ok {
		if value, e := expandInt(v); !e {
      out.TracePayloadLen = value
    }
	}

	if v, ok := m["tunnel"]; ok {
		if value, e := expandString(v); !e {
      out.Tunnel = value
    }
	}

	if v, ok := m["version"]; ok {
		if value, e := expandString(v); !e {
      out.Version = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandClassicNetworkingSpec(in interface{}) (kops.ClassicNetworkingSpec, bool) {
	out := kops.ClassicNetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandCloudConfiguration(in interface{}) (kops.CloudConfiguration, bool) {
	d := in.([]interface{})
	out := kops.CloudConfiguration{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["disable_security_group_ingress"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableSecurityGroupIngress = &value
    }
	}

	if v, ok := m["elb_security_group"]; ok {
		if value, e := expandString(v); !e {
      out.ElbSecurityGroup = &value
    }
	}

	if v, ok := m["multizone"]; ok {
		if value, e := expandBool(v); !e {
      out.Multizone = &value
    }
	}

	if v, ok := m["node_instance_prefix"]; ok {
		if value, e := expandString(v); !e {
      out.NodeInstancePrefix = &value
    }
	}

	if v, ok := m["node_tags"]; ok {
		if value, e := expandString(v); !e {
      out.NodeTags = &value
    }
	}

	if v, ok := m["openstack"]; ok {
		if value, e := expandOpenstackConfiguration(v); !e {
      out.Openstack = &value
    }
	}

	if v, ok := m["spotinst_orientation"]; ok {
		if value, e := expandString(v); !e {
      out.SpotinstOrientation = &value
    }
	}

	if v, ok := m["spotinst_product"]; ok {
		if value, e := expandString(v); !e {
      out.SpotinstProduct = &value
    }
	}

	if v, ok := m["v_sphere_core_dns_server"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereCoreDNSServer = &value
    }
	}

	if v, ok := m["v_sphere_datacenter"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereDatacenter = &value
    }
	}

	if v, ok := m["v_sphere_datastore"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereDatastore = &value
    }
	}

	if v, ok := m["v_sphere_password"]; ok {
		if value, e := expandString(v); !e {
      out.VSpherePassword = &value
    }
	}

	if v, ok := m["v_sphere_resource_pool"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereResourcePool = &value
    }
	}

	if v, ok := m["v_sphere_server"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereServer = &value
    }
	}

	if v, ok := m["v_sphere_username"]; ok {
		if value, e := expandString(v); !e {
      out.VSphereUsername = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandCloudControllerManagerConfig(in interface{}) (kops.CloudControllerManagerConfig, bool) {
	d := in.([]interface{})
	out := kops.CloudControllerManagerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["allocate_node_cid_rss"]; ok {
		if value, e := expandBool(v); !e {
      out.AllocateNodeCIDRs = &value
    }
	}

	if v, ok := m["cidr_allocator_type"]; ok {
		if value, e := expandString(v); !e {
      out.CIDRAllocatorType = &value
    }
	}

	if v, ok := m["cloud_provider"]; ok {
		if value, e := expandString(v); !e {
      out.CloudProvider = value
    }
	}

	if v, ok := m["cluster_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterCIDR = value
    }
	}

	if v, ok := m["cluster_name"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterName = value
    }
	}

	if v, ok := m["configure_cloud_routes"]; ok {
		if value, e := expandBool(v); !e {
      out.ConfigureCloudRoutes = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["leader_election"]; ok {
		if value, e := expandLeaderElectionConfiguration(v); !e {
      out.LeaderElection = &value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandInt32(v); !e {
      out.LogLevel = value
    }
	}

	if v, ok := m["master"]; ok {
		if value, e := expandString(v); !e {
      out.Master = value
    }
	}

	if v, ok := m["use_service_account_credentials"]; ok {
		if value, e := expandBool(v); !e {
      out.UseServiceAccountCredentials = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandClusterSpec(in interface{}) (kops.ClusterSpec, bool) {
	d := in.([]interface{})
	out := kops.ClusterSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["api"]; ok {
		if value, e := expandAccessSpec(v); !e {
      out.API = &value
    }
	}

	if v, ok := m["additional_network_cid_rss"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AdditionalNetworkCIDRs = value
    }
	}

	if v, ok := m["additional_policies"]; ok {
		if value, e := expandStringMap(v); !e {
      out.AdditionalPolicies = &value
    }
	}

	if v, ok := m["additional_sans"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AdditionalSANs = value
    }
	}

	if v, ok := m["addons"]; ok {
		if value, e := expandAddonSpecSlice(v); !e {
      out.Addons = value
    }
	}

	if v, ok := m["assets"]; ok {
		if value, e := expandAssets(v); !e {
      out.Assets = &value
    }
	}

	if v, ok := m["authentication"]; ok {
		if value, e := expandAuthenticationSpec(v); !e {
      out.Authentication = &value
    }
	}

	if v, ok := m["authorization"]; ok {
		if value, e := expandAuthorizationSpec(v); !e {
      out.Authorization = &value
    }
	}

	if v, ok := m["channel"]; ok {
		if value, e := expandString(v); !e {
      out.Channel = value
    }
	}

	if v, ok := m["cloud_config"]; ok {
		if value, e := expandCloudConfiguration(v); !e {
      out.CloudConfig = &value
    }
	}

	if v, ok := m["cloud_labels"]; ok {
		if value, e := expandStringMap(v); !e {
      out.CloudLabels = value
    }
	}

	if v, ok := m["cloud_provider"]; ok {
		if value, e := expandString(v); !e {
      out.CloudProvider = value
    }
	}

	if v, ok := m["cluster_dns_domain"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterDNSDomain = value
    }
	}

	if v, ok := m["config_base"]; ok {
		if value, e := expandString(v); !e {
      out.ConfigBase = value
    }
	}

	if v, ok := m["config_store"]; ok {
		if value, e := expandString(v); !e {
      out.ConfigStore = value
    }
	}

	if v, ok := m["dns_zone"]; ok {
		if value, e := expandString(v); !e {
      out.DNSZone = value
    }
	}

	if v, ok := m["disable_subnet_tags"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableSubnetTags = value
    }
	}

	if v, ok := m["docker"]; ok {
		if value, e := expandDockerConfig(v); !e {
      out.Docker = &value
    }
	}

	if v, ok := m["egress_proxy"]; ok {
		if value, e := expandEgressProxySpec(v); !e {
      out.EgressProxy = &value
    }
	}

	if v, ok := m["encryption_config"]; ok {
		if value, e := expandBool(v); !e {
      out.EncryptionConfig = &value
    }
	}

	if v, ok := m["etcd_clusters"]; ok {
		if value, e := expandEtcdClusterSpecSlice(v); !e {
      out.EtcdClusters = value
    }
	}

	if v, ok := m["cloud_controller_manager"]; ok {
		if value, e := expandCloudControllerManagerConfig(v); !e {
      out.ExternalCloudControllerManager = &value
    }
	}

	if v, ok := m["external_dns"]; ok {
		if value, e := expandExternalDNSConfig(v); !e {
      out.ExternalDNS = &value
    }
	}

	if v, ok := m["file_assets"]; ok {
		if value, e := expandFileAssetSpecSlice(v); !e {
      out.FileAssets = value
    }
	}

	if v, ok := m["hooks"]; ok {
		if value, e := expandHookSpecSlice(v); !e {
      out.Hooks = value
    }
	}

	if v, ok := m["iam"]; ok {
		if value, e := expandIAMSpec(v); !e {
      out.IAM = &value
    }
	}

	if v, ok := m["isolate_masters"]; ok {
		if value, e := expandBool(v); !e {
      out.IsolateMasters = &value
    }
	}

	if v, ok := m["key_store"]; ok {
		if value, e := expandString(v); !e {
      out.KeyStore = value
    }
	}

	if v, ok := m["kube_api_server"]; ok {
		if value, e := expandKubeAPIServerConfig(v); !e {
      out.KubeAPIServer = &value
    }
	}

	if v, ok := m["kube_controller_manager"]; ok {
		if value, e := expandKubeControllerManagerConfig(v); !e {
      out.KubeControllerManager = &value
    }
	}

	if v, ok := m["kube_dns"]; ok {
		if value, e := expandKubeDNSConfig(v); !e {
      out.KubeDNS = &value
    }
	}

	if v, ok := m["kube_proxy"]; ok {
		if value, e := expandKubeProxyConfig(v); !e {
      out.KubeProxy = &value
    }
	}

	if v, ok := m["kube_scheduler"]; ok {
		if value, e := expandKubeSchedulerConfig(v); !e {
      out.KubeScheduler = &value
    }
	}

	if v, ok := m["kubelet"]; ok {
		if value, e := expandKubeletConfigSpec(v); !e {
      out.Kubelet = &value
    }
	}

	if v, ok := m["kubernetes_api_access"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.KubernetesAPIAccess = value
    }
	}

	if v, ok := m["kubernetes_version"]; ok {
		if value, e := expandString(v); !e {
      out.KubernetesVersion = value
    }
	}

	if v, ok := m["master_internal_name"]; ok {
		if value, e := expandString(v); !e {
      out.MasterInternalName = value
    }
	}

	if v, ok := m["master_kubelet"]; ok {
		if value, e := expandKubeletConfigSpec(v); !e {
      out.MasterKubelet = &value
    }
	}

	if v, ok := m["master_public_name"]; ok {
		if value, e := expandString(v); !e {
      out.MasterPublicName = value
    }
	}

	if v, ok := m["network_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.NetworkCIDR = value
    }
	}

	if v, ok := m["network_id"]; ok {
		if value, e := expandString(v); !e {
      out.NetworkID = value
    }
	}

	if v, ok := m["networking"]; ok {
		if value, e := expandNetworkingSpec(v); !e {
      out.Networking = &value
    }
	}

	if v, ok := m["node_authorization"]; ok {
		if value, e := expandNodeAuthorizationSpec(v); !e {
      out.NodeAuthorization = &value
    }
	}

	if v, ok := m["node_port_access"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.NodePortAccess = value
    }
	}

	if v, ok := m["non_masquerade_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.NonMasqueradeCIDR = value
    }
	}

	if v, ok := m["pod_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.PodCIDR = value
    }
	}

	if v, ok := m["project"]; ok {
		if value, e := expandString(v); !e {
      out.Project = value
    }
	}

	if v, ok := m["ssh_access"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.SSHAccess = value
    }
	}

	if v, ok := m["ssh_key_name"]; ok {
		if value, e := expandString(v); !e {
      out.SSHKeyName = value
    }
	}

	if v, ok := m["secret_store"]; ok {
		if value, e := expandString(v); !e {
      out.SecretStore = value
    }
	}

	if v, ok := m["service_cluster_ip_range"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceClusterIPRange = value
    }
	}

	if v, ok := m["subnets"]; ok {
		if value, e := expandClusterSubnetSpecSlice(v); !e {
      out.Subnets = value
    }
	}

	if v, ok := m["target"]; ok {
		if value, e := expandTargetSpec(v); !e {
      out.Target = &value
    }
	}

	if v, ok := m["topology"]; ok {
		if value, e := expandTopologySpec(v); !e {
      out.Topology = &value
    }
	}

	if v, ok := m["update_policy"]; ok {
		if value, e := expandString(v); !e {
      out.UpdatePolicy = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandClusterSubnetSpecSlice(in interface{}) ([]kops.ClusterSubnetSpec, bool) {
	d := in.([]interface{})
	out := make([]kops.ClusterSubnetSpec , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = kops.ClusterSubnetSpec{}

		if v, ok := d[i].(map[string]interface{})["cidr"]; ok {
      if value, e := expandString(v); !e {
        out[i].CIDR = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["egress"]; ok {
      if value, e := expandString(v); !e {
        out[i].Egress = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
      if value, e := expandString(v); !e {
        out[i].Name = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["id"]; ok {
      if value, e := expandString(v); !e {
        out[i].ProviderID = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["public_ip"]; ok {
      if value, e := expandString(v); !e {
        out[i].PublicIP = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["region"]; ok {
      if value, e := expandString(v); !e {
        out[i].Region = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["type"]; ok {
      if value, e := expandSubnetType(v); !e {
        out[i].Type = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["zone"]; ok {
      if value, e := expandString(v); !e {
        out[i].Zone = value
      }
		}
	}

	return out, false
}

func expandDNSAccessSpec(in interface{}) (kops.DNSAccessSpec, bool) {
	out := kops.DNSAccessSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandDNSSpec(in interface{}) (kops.DNSSpec, bool) {
	d := in.([]interface{})
	out := kops.DNSSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["type"]; ok {
		if value, e := expandDNSType(v); !e {
      out.Type = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandDNSType(in interface{}) (kops.DNSType, bool) {
	d := in.(string)
	r := kops.DNSType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandDockerConfig(in interface{}) (kops.DockerConfig, bool) {
	d := in.([]interface{})
	out := kops.DockerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["authorization_plugins"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AuthorizationPlugins = value
    }
	}

	if v, ok := m["bridge"]; ok {
		if value, e := expandString(v); !e {
      out.Bridge = &value
    }
	}

	if v, ok := m["bridge_ip"]; ok {
		if value, e := expandString(v); !e {
      out.BridgeIP = &value
    }
	}

	if v, ok := m["data_root"]; ok {
		if value, e := expandString(v); !e {
      out.DataRoot = &value
    }
	}

	if v, ok := m["default_ulimit"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.DefaultUlimit = value
    }
	}

	if v, ok := m["exec_opt"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.ExecOpt = value
    }
	}

	if v, ok := m["exec_root"]; ok {
		if value, e := expandString(v); !e {
      out.ExecRoot = &value
    }
	}

	if v, ok := m["experimental"]; ok {
		if value, e := expandBool(v); !e {
      out.Experimental = &value
    }
	}

	if v, ok := m["hosts"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.Hosts = value
    }
	}

	if v, ok := m["ip_masq"]; ok {
		if value, e := expandBool(v); !e {
      out.IPMasq = &value
    }
	}

	if v, ok := m["ip_tables"]; ok {
		if value, e := expandBool(v); !e {
      out.IPTables = &value
    }
	}

	if v, ok := m["insecure_registries"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.InsecureRegistries = value
    }
	}

	if v, ok := m["insecure_registry"]; ok {
		if value, e := expandString(v); !e {
      out.InsecureRegistry = &value
    }
	}

	if v, ok := m["live_restore"]; ok {
		if value, e := expandBool(v); !e {
      out.LiveRestore = &value
    }
	}

	if v, ok := m["log_driver"]; ok {
		if value, e := expandString(v); !e {
      out.LogDriver = &value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandString(v); !e {
      out.LogLevel = &value
    }
	}

	if v, ok := m["log_opt"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.LogOpt = value
    }
	}

	if v, ok := m["mtu"]; ok {
		if value, e := expandInt32(v); !e {
      out.MTU = &value
    }
	}

	if v, ok := m["metrics_address"]; ok {
		if value, e := expandString(v); !e {
      out.MetricsAddress = &value
    }
	}

	if v, ok := m["registry_mirrors"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.RegistryMirrors = value
    }
	}

	if v, ok := m["skip_install"]; ok {
		if value, e := expandBool(v); !e {
      out.SkipInstall = value
    }
	}

	if v, ok := m["storage"]; ok {
		if value, e := expandString(v); !e {
      out.Storage = &value
    }
	}

	if v, ok := m["storage_opts"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.StorageOpts = value
    }
	}

	if v, ok := m["user_namespace_remap"]; ok {
		if value, e := expandString(v); !e {
      out.UserNamespaceRemap = value
    }
	}

	if v, ok := m["version"]; ok {
		if value, e := expandString(v); !e {
      out.Version = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandEgressProxySpec(in interface{}) (kops.EgressProxySpec, bool) {
	d := in.([]interface{})
	out := kops.EgressProxySpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["http_proxy"]; ok {
		if value, e := expandHTTPProxy(v); !e {
      out.HTTPProxy = value
    }
	}

	if v, ok := m["excludes"]; ok {
		if value, e := expandString(v); !e {
      out.ProxyExcludes = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandEtcdBackupSpec(in interface{}) (kops.EtcdBackupSpec, bool) {
	d := in.([]interface{})
	out := kops.EtcdBackupSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["backup_store"]; ok {
		if value, e := expandString(v); !e {
      out.BackupStore = value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandEtcdClusterSpecSlice(in interface{}) ([]*kops.EtcdClusterSpec, bool) {
	d := in.([]interface{})
	out := make([]*kops.EtcdClusterSpec , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = &kops.EtcdClusterSpec{}

		if v, ok := d[i].(map[string]interface{})["backups"]; ok {
      if value, e := expandEtcdBackupSpec(v); !e {
        out[i].Backups = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["cpu_request"]; ok {
      if value, e := expandQuantity(v); !e {
        out[i].CPURequest = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["enable_etcd_tls"]; ok {
      if value, e := expandBool(v); !e {
        out[i].EnableEtcdTLS = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["enable_tls_auth"]; ok {
      if value, e := expandBool(v); !e {
        out[i].EnableTLSAuth = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["heartbeat_interval"]; ok {
      if value, e := expandDuration(v); !e {
        out[i].HeartbeatInterval = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["image"]; ok {
      if value, e := expandString(v); !e {
        out[i].Image = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["leader_election_timeout"]; ok {
      if value, e := expandDuration(v); !e {
        out[i].LeaderElectionTimeout = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["manager"]; ok {
      if value, e := expandEtcdManagerSpec(v); !e {
        out[i].Manager = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["etcd_members"]; ok {
      if value, e := expandEtcdMemberSpecSlice(v); !e {
        out[i].Members = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["memory_request"]; ok {
      if value, e := expandQuantity(v); !e {
        out[i].MemoryRequest = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
      if value, e := expandString(v); !e {
        out[i].Name = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["provider"]; ok {
      if value, e := expandEtcdProviderType(v); !e {
        out[i].Provider = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["version"]; ok {
      if value, e := expandString(v); !e {
        out[i].Version = value
      }
		}
	}

	return out, false
}

func expandEtcdManagerSpec(in interface{}) (kops.EtcdManagerSpec, bool) {
	d := in.([]interface{})
	out := kops.EtcdManagerSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandEtcdMemberSpecSlice(in interface{}) ([]*kops.EtcdMemberSpec, bool) {
	d := in.([]interface{})
	out := make([]*kops.EtcdMemberSpec , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = &kops.EtcdMemberSpec{}

		if v, ok := d[i].(map[string]interface{})["encrypted_volume"]; ok {
      if value, e := expandBool(v); !e {
        out[i].EncryptedVolume = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["instance_group"]; ok {
      if value, e := expandString(v); !e {
        out[i].InstanceGroup = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["kms_key_id"]; ok {
      if value, e := expandString(v); !e {
        out[i].KmsKeyId = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
      if value, e := expandString(v); !e {
        out[i].Name = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["volume_iops"]; ok {
      if value, e := expandInt32(v); !e {
        out[i].VolumeIops = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["volume_size"]; ok {
      if value, e := expandInt32(v); !e {
        out[i].VolumeSize = &value
      }
		}

		if v, ok := d[i].(map[string]interface{})["volume_type"]; ok {
      if value, e := expandString(v); !e {
        out[i].VolumeType = &value
      }
		}
	}

	return out, false
}

func expandEtcdProviderType(in interface{}) (kops.EtcdProviderType, bool) {
	d := in.(string)
	r := kops.EtcdProviderType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandExecContainerAction(in interface{}) (kops.ExecContainerAction, bool) {
	d := in.([]interface{})
	out := kops.ExecContainerAction{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["command"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.Command = value
    }
	}

	if v, ok := m["environment"]; ok {
		if value, e := expandStringMap(v); !e {
      out.Environment = value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandExternalDNSConfig(in interface{}) (kops.ExternalDNSConfig, bool) {
	d := in.([]interface{})
	out := kops.ExternalDNSConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["disable"]; ok {
		if value, e := expandBool(v); !e {
      out.Disable = value
    }
	}

	if v, ok := m["watch_ingress"]; ok {
		if value, e := expandBool(v); !e {
      out.WatchIngress = &value
    }
	}

	if v, ok := m["watch_namespace"]; ok {
		if value, e := expandString(v); !e {
      out.WatchNamespace = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandExternalNetworkingSpec(in interface{}) (kops.ExternalNetworkingSpec, bool) {
	out := kops.ExternalNetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandFields(in interface{}) (v1.Fields, bool) {
	d := in.([]interface{})
	out := v1.Fields{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	{
		if value, e := expandFieldsMap(m); !e {
      out.Map = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandFieldsMap(in interface{}) (map[string]v1.Fields, bool) {
	out := make(map[string]v1.Fields)
  d := in.(map[string]interface{})
  
  if len(d) < 1 {
    return out, true
  }

	for k, v := range d {
		out[k] = v.(v1.Fields)
	}

	return out, false
}

func expandFlannelNetworkingSpec(in interface{}) (kops.FlannelNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.FlannelNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["backend"]; ok {
		if value, e := expandString(v); !e {
      out.Backend = value
    }
	}

	if v, ok := m["iptables_resync_seconds"]; ok {
		if value, e := expandInt32(v); !e {
      out.IptablesResyncSeconds = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandFloat64(in interface{}) (float64, bool) {
	d := in.(float64)
	r := float64(d)
  out := r
  
  if out == 0 {
    return out, true
  }

	return out, false
}

func expandFormat(in interface{}) (resource.Format, bool) {
	d := in.(string)
	r := resource.Format(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandGCENetworkingSpec(in interface{}) (kops.GCENetworkingSpec, bool) {
	out := kops.GCENetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandHTTPProxy(in interface{}) (kops.HTTPProxy, bool) {
	d := in.([]interface{})
	out := kops.HTTPProxy{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["host"]; ok {
		if value, e := expandString(v); !e {
      out.Host = value
    }
	}

	if v, ok := m["port"]; ok {
		if value, e := expandInt(v); !e {
      out.Port = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandIAMSpec(in interface{}) (kops.IAMSpec, bool) {
	d := in.([]interface{})
	out := kops.IAMSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["allow_container_registry"]; ok {
		if value, e := expandBool(v); !e {
      out.AllowContainerRegistry = value
    }
	}

	{
		if value, e := expandBool(m["legacy"]); !e {
      out.Legacy = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandInitializerSlice(in interface{}) ([]v1.Initializer, bool) {
	d := in.([]interface{})
	out := make([]v1.Initializer , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = v1.Initializer{}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
      if value, e := expandString(v); !e {
        out[i].Name = value
      }
		}
	}

	return out, false
}

func expandInstanceGroupRoleSlice(in interface{}) ([]kops.InstanceGroupRole, bool) {
	d := in.([]interface{})
	out := make([]kops.InstanceGroupRole , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = d[i].(kops.InstanceGroupRole)
	}

	return out, false
}

func expandInt(in interface{}) (int, bool) {
	d := in.(int)
	r := int(d)
  out := r
  
  if out == 0 {
    return out, true
  }

	return out, false
}

func expandKopeioAuthenticationSpec(in interface{}) (kops.KopeioAuthenticationSpec, bool) {
	out := kops.KopeioAuthenticationSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandKopeioNetworkingSpec(in interface{}) (kops.KopeioNetworkingSpec, bool) {
	out := kops.KopeioNetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandKubeAPIServerConfig(in interface{}) (kops.KubeAPIServerConfig, bool) {
	d := in.([]interface{})
	out := kops.KubeAPIServerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["api_audiences"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.APIAudiences = value
    }
	}

	if v, ok := m["api_server_count"]; ok {
		if value, e := expandInt32(v); !e {
      out.APIServerCount = &value
    }
	}

	if v, ok := m["address"]; ok {
		if value, e := expandString(v); !e {
      out.Address = value
    }
	}

	if v, ok := m["admission_control"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AdmissionControl = value
    }
	}

	if v, ok := m["admission_control_config_file"]; ok {
		if value, e := expandString(v); !e {
      out.AdmissionControlConfigFile = value
    }
	}

	if v, ok := m["allow_privileged"]; ok {
		if value, e := expandBool(v); !e {
      out.AllowPrivileged = &value
    }
	}

	if v, ok := m["anonymous_auth"]; ok {
		if value, e := expandBool(v); !e {
      out.AnonymousAuth = &value
    }
	}

	if v, ok := m["append_admission_plugins"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AppendAdmissionPlugins = value
    }
	}

	if v, ok := m["audit_log_format"]; ok {
		if value, e := expandString(v); !e {
      out.AuditLogFormat = &value
    }
	}

	if v, ok := m["audit_log_max_age"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditLogMaxAge = &value
    }
	}

	if v, ok := m["audit_log_max_backups"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditLogMaxBackups = &value
    }
	}

	if v, ok := m["audit_log_max_size"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditLogMaxSize = &value
    }
	}

	if v, ok := m["audit_log_path"]; ok {
		if value, e := expandString(v); !e {
      out.AuditLogPath = &value
    }
	}

	if v, ok := m["audit_policy_file"]; ok {
		if value, e := expandString(v); !e {
      out.AuditPolicyFile = value
    }
	}

	if v, ok := m["audit_webhook_batch_buffer_size"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditWebhookBatchBufferSize = &value
    }
	}

	if v, ok := m["audit_webhook_batch_max_size"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditWebhookBatchMaxSize = &value
    }
	}

	if v, ok := m["audit_webhook_batch_max_wait"]; ok {
		if value, e := expandDuration(v); !e {
      out.AuditWebhookBatchMaxWait = &value
    }
	}

	if v, ok := m["audit_webhook_batch_throttle_burst"]; ok {
		if value, e := expandInt32(v); !e {
      out.AuditWebhookBatchThrottleBurst = &value
    }
	}

	if v, ok := m["audit_webhook_batch_throttle_enable"]; ok {
		if value, e := expandBool(v); !e {
      out.AuditWebhookBatchThrottleEnable = &value
    }
	}

	if v, ok := m["audit_webhook_batch_throttle_qps"]; ok {
		if value, e := expandFloat32(v); !e {
      out.AuditWebhookBatchThrottleQps = &value
    }
	}

	if v, ok := m["audit_webhook_config_file"]; ok {
		if value, e := expandString(v); !e {
      out.AuditWebhookConfigFile = value
    }
	}

	if v, ok := m["audit_webhook_initial_backoff"]; ok {
		if value, e := expandDuration(v); !e {
      out.AuditWebhookInitialBackoff = &value
    }
	}

	if v, ok := m["audit_webhook_mode"]; ok {
		if value, e := expandString(v); !e {
      out.AuditWebhookMode = value
    }
	}

	if v, ok := m["authentication_token_webhook_cache_ttl"]; ok {
		if value, e := expandDuration(v); !e {
      out.AuthenticationTokenWebhookCacheTTL = &value
    }
	}

	if v, ok := m["authentication_token_webhook_config_file"]; ok {
		if value, e := expandString(v); !e {
      out.AuthenticationTokenWebhookConfigFile = &value
    }
	}

	if v, ok := m["authorization_mode"]; ok {
		if value, e := expandString(v); !e {
      out.AuthorizationMode = &value
    }
	}

	if v, ok := m["authorization_rbac_super_user"]; ok {
		if value, e := expandString(v); !e {
      out.AuthorizationRBACSuperUser = &value
    }
	}

	if v, ok := m["authorization_webhook_cache_authorized_ttl"]; ok {
		if value, e := expandDuration(v); !e {
      out.AuthorizationWebhookCacheAuthorizedTTL = &value
    }
	}

	if v, ok := m["authorization_webhook_cache_unauthorized_ttl"]; ok {
		if value, e := expandDuration(v); !e {
      out.AuthorizationWebhookCacheUnauthorizedTTL = &value
    }
	}

	if v, ok := m["authorization_webhook_config_file"]; ok {
		if value, e := expandString(v); !e {
      out.AuthorizationWebhookConfigFile = &value
    }
	}

	if v, ok := m["basic_auth_file"]; ok {
		if value, e := expandString(v); !e {
      out.BasicAuthFile = value
    }
	}

	if v, ok := m["bind_address"]; ok {
		if value, e := expandString(v); !e {
      out.BindAddress = value
    }
	}

	if v, ok := m["cpu_request"]; ok {
		if value, e := expandString(v); !e {
      out.CPURequest = value
    }
	}

	if v, ok := m["client_ca_file"]; ok {
		if value, e := expandString(v); !e {
      out.ClientCAFile = value
    }
	}

	if v, ok := m["cloud_provider"]; ok {
		if value, e := expandString(v); !e {
      out.CloudProvider = value
    }
	}

	if v, ok := m["disable_admission_plugins"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.DisableAdmissionPlugins = value
    }
	}

	if v, ok := m["disable_basic_auth"]; ok {
		if value, e := expandBool(v); !e {
      out.DisableBasicAuth = value
    }
	}

	if v, ok := m["enable_admission_plugins"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.EnableAdmissionPlugins = value
    }
	}

	if v, ok := m["enable_aggregator_routing"]; ok {
		if value, e := expandBool(v); !e {
      out.EnableAggregatorRouting = &value
    }
	}

	if v, ok := m["enable_bootstrap_token_auth"]; ok {
		if value, e := expandBool(v); !e {
      out.EnableBootstrapAuthToken = &value
    }
	}

	if v, ok := m["etcd_ca_file"]; ok {
		if value, e := expandString(v); !e {
      out.EtcdCAFile = value
    }
	}

	if v, ok := m["etcd_cert_file"]; ok {
		if value, e := expandString(v); !e {
      out.EtcdCertFile = value
    }
	}

	if v, ok := m["etcd_key_file"]; ok {
		if value, e := expandString(v); !e {
      out.EtcdKeyFile = value
    }
	}

	if v, ok := m["etcd_quorum_read"]; ok {
		if value, e := expandBool(v); !e {
      out.EtcdQuorumRead = &value
    }
	}

	if v, ok := m["etcd_servers"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.EtcdServers = value
    }
	}

	if v, ok := m["etcd_servers_overrides"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.EtcdServersOverrides = value
    }
	}

	if v, ok := m["event_ttl"]; ok {
		if value, e := expandDuration(v); !e {
      out.EventTTL = &value
    }
	}

	if v, ok := m["experimental_encryption_provider_config"]; ok {
		if value, e := expandString(v); !e {
      out.ExperimentalEncryptionProviderConfig = &value
    }
	}

	if v, ok := m["feature_gates"]; ok {
		if value, e := expandStringMap(v); !e {
      out.FeatureGates = value
    }
	}

	if v, ok := m["http_2max_streams_per_connection"]; ok {
		if value, e := expandInt32(v); !e {
      out.HTTP2MaxStreamsPerConnection = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["insecure_bind_address"]; ok {
		if value, e := expandString(v); !e {
      out.InsecureBindAddress = value
    }
	}

	if v, ok := m["insecure_port"]; ok {
		if value, e := expandInt32(v); !e {
      out.InsecurePort = value
    }
	}

	if v, ok := m["kubelet_client_certificate"]; ok {
		if value, e := expandString(v); !e {
      out.KubeletClientCertificate = value
    }
	}

	if v, ok := m["kubelet_client_key"]; ok {
		if value, e := expandString(v); !e {
      out.KubeletClientKey = value
    }
	}

	if v, ok := m["kubelet_preferred_address_types"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.KubeletPreferredAddressTypes = value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandInt32(v); !e {
      out.LogLevel = value
    }
	}

	if v, ok := m["max_mutating_requests_inflight"]; ok {
		if value, e := expandInt32(v); !e {
      out.MaxMutatingRequestsInflight = value
    }
	}

	if v, ok := m["max_requests_inflight"]; ok {
		if value, e := expandInt32(v); !e {
      out.MaxRequestsInflight = value
    }
	}

	if v, ok := m["min_request_timeout"]; ok {
		if value, e := expandInt32(v); !e {
      out.MinRequestTimeout = &value
    }
	}

	if v, ok := m["oidc_ca_file"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCCAFile = &value
    }
	}

	if v, ok := m["oidc_client_id"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCClientID = &value
    }
	}

	if v, ok := m["oidc_groups_claim"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCGroupsClaim = &value
    }
	}

	if v, ok := m["oidc_groups_prefix"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCGroupsPrefix = &value
    }
	}

	if v, ok := m["oidc_issuer_url"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCIssuerURL = &value
    }
	}

	if v, ok := m["oidc_required_claim"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.OIDCRequiredClaim = value
    }
	}

	if v, ok := m["oidc_username_claim"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCUsernameClaim = &value
    }
	}

	if v, ok := m["oidc_username_prefix"]; ok {
		if value, e := expandString(v); !e {
      out.OIDCUsernamePrefix = &value
    }
	}

	if v, ok := m["proxy_client_cert_file"]; ok {
		if value, e := expandString(v); !e {
      out.ProxyClientCertFile = &value
    }
	}

	if v, ok := m["proxy_client_key_file"]; ok {
		if value, e := expandString(v); !e {
      out.ProxyClientKeyFile = &value
    }
	}

	if v, ok := m["requestheader_allowed_names"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.RequestheaderAllowedNames = value
    }
	}

	if v, ok := m["requestheader_client_ca_file"]; ok {
		if value, e := expandString(v); !e {
      out.RequestheaderClientCAFile = value
    }
	}

	if v, ok := m["requestheader_extra_header_prefixes"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.RequestheaderExtraHeaderPrefixes = value
    }
	}

	if v, ok := m["requestheader_group_headers"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.RequestheaderGroupHeaders = value
    }
	}

	if v, ok := m["requestheader_username_headers"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.RequestheaderUsernameHeaders = value
    }
	}

	if v, ok := m["runtime_config"]; ok {
		if value, e := expandStringMap(v); !e {
      out.RuntimeConfig = value
    }
	}

	if v, ok := m["secure_port"]; ok {
		if value, e := expandInt32(v); !e {
      out.SecurePort = value
    }
	}

	if v, ok := m["service_account_issuer"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceAccountIssuer = &value
    }
	}

	if v, ok := m["service_account_key_file"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.ServiceAccountKeyFile = value
    }
	}

	if v, ok := m["service_account_signing_key_file"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceAccountSigningKeyFile = &value
    }
	}

	if v, ok := m["service_cluster_ip_range"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceClusterIPRange = value
    }
	}

	if v, ok := m["service_node_port_range"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceNodePortRange = value
    }
	}

	if v, ok := m["storage_backend"]; ok {
		if value, e := expandString(v); !e {
      out.StorageBackend = &value
    }
	}

	if v, ok := m["tls_cert_file"]; ok {
		if value, e := expandString(v); !e {
      out.TLSCertFile = value
    }
	}

	if v, ok := m["tls_cipher_suites"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.TLSCipherSuites = value
    }
	}

	if v, ok := m["tls_min_version"]; ok {
		if value, e := expandString(v); !e {
      out.TLSMinVersion = value
    }
	}

	if v, ok := m["tls_private_key_file"]; ok {
		if value, e := expandString(v); !e {
      out.TLSPrivateKeyFile = value
    }
	}

	if v, ok := m["target_ram_mb"]; ok {
		if value, e := expandInt32(v); !e {
      out.TargetRamMb = value
    }
	}

	if v, ok := m["token_auth_file"]; ok {
		if value, e := expandString(v); !e {
      out.TokenAuthFile = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandKubeControllerManagerConfig(in interface{}) (kops.KubeControllerManagerConfig, bool) {
	d := in.([]interface{})
	out := kops.KubeControllerManagerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["allocate_node_cid_rss"]; ok {
		if value, e := expandBool(v); !e {
      out.AllocateNodeCIDRs = &value
    }
	}

	if v, ok := m["attach_detach_reconcile_sync_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.AttachDetachReconcileSyncPeriod = &value
    }
	}

	if v, ok := m["cidr_allocator_type"]; ok {
		if value, e := expandString(v); !e {
      out.CIDRAllocatorType = &value
    }
	}

	if v, ok := m["cloud_provider"]; ok {
		if value, e := expandString(v); !e {
      out.CloudProvider = value
    }
	}

	if v, ok := m["cluster_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterCIDR = value
    }
	}

	if v, ok := m["cluster_name"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterName = value
    }
	}

	if v, ok := m["configure_cloud_routes"]; ok {
		if value, e := expandBool(v); !e {
      out.ConfigureCloudRoutes = &value
    }
	}

	if v, ok := m["controllers"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.Controllers = value
    }
	}

	if v, ok := m["experimental_cluster_signing_duration"]; ok {
		if value, e := expandDuration(v); !e {
      out.ExperimentalClusterSigningDuration = &value
    }
	}

	if v, ok := m["feature_gates"]; ok {
		if value, e := expandStringMap(v); !e {
      out.FeatureGates = value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_downscale_delay"]; ok {
		if value, e := expandDuration(v); !e {
      out.HorizontalPodAutoscalerDownscaleDelay = &value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_downscale_stabilization"]; ok {
		if value, e := expandDuration(v); !e {
      out.HorizontalPodAutoscalerDownscaleStabilization = &value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_sync_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.HorizontalPodAutoscalerSyncPeriod = &value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_tolerance"]; ok {
		if value, e := expandFloat64(v); !e {
      out.HorizontalPodAutoscalerTolerance = &value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_upscale_delay"]; ok {
		if value, e := expandDuration(v); !e {
      out.HorizontalPodAutoscalerUpscaleDelay = &value
    }
	}

	if v, ok := m["horizontal_pod_autoscaler_use_rest_clients"]; ok {
		if value, e := expandBool(v); !e {
      out.HorizontalPodAutoscalerUseRestClients = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["kube_api_burst"]; ok {
		if value, e := expandInt32(v); !e {
      out.KubeAPIBurst = &value
    }
	}

	if v, ok := m["kube_apiqps"]; ok {
		if value, e := expandFloat32(v); !e {
      out.KubeAPIQPS = &value
    }
	}

	if v, ok := m["leader_election"]; ok {
		if value, e := expandLeaderElectionConfiguration(v); !e {
      out.LeaderElection = &value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandInt32(v); !e {
      out.LogLevel = value
    }
	}

	if v, ok := m["master"]; ok {
		if value, e := expandString(v); !e {
      out.Master = value
    }
	}

	if v, ok := m["min_resync_period"]; ok {
		if value, e := expandString(v); !e {
      out.MinResyncPeriod = value
    }
	}

	if v, ok := m["node_cidr_mask_size"]; ok {
		if value, e := expandInt32(v); !e {
      out.NodeCIDRMaskSize = &value
    }
	}

	if v, ok := m["node_monitor_grace_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.NodeMonitorGracePeriod = &value
    }
	}

	if v, ok := m["node_monitor_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.NodeMonitorPeriod = &value
    }
	}

	if v, ok := m["pod_eviction_timeout"]; ok {
		if value, e := expandDuration(v); !e {
      out.PodEvictionTimeout = &value
    }
	}

	if v, ok := m["root_ca_file"]; ok {
		if value, e := expandString(v); !e {
      out.RootCAFile = value
    }
	}

	if v, ok := m["service_account_private_key_file"]; ok {
		if value, e := expandString(v); !e {
      out.ServiceAccountPrivateKeyFile = value
    }
	}

	if v, ok := m["tls_cipher_suites"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.TLSCipherSuites = value
    }
	}

	if v, ok := m["tls_min_version"]; ok {
		if value, e := expandString(v); !e {
      out.TLSMinVersion = value
    }
	}

	if v, ok := m["terminated_pod_gc_threshold"]; ok {
		if value, e := expandInt32(v); !e {
      out.TerminatedPodGCThreshold = &value
    }
	}

	if v, ok := m["use_service_account_credentials"]; ok {
		if value, e := expandBool(v); !e {
      out.UseServiceAccountCredentials = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandKubeDNSConfig(in interface{}) (kops.KubeDNSConfig, bool) {
	d := in.([]interface{})
	out := kops.KubeDNSConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["cpu_request"]; ok {
		if value, e := expandQuantity(v); !e {
      out.CPURequest = &value
    }
	}

	if v, ok := m["cache_max_concurrent"]; ok {
		if value, e := expandInt(v); !e {
      out.CacheMaxConcurrent = value
    }
	}

	if v, ok := m["cache_max_size"]; ok {
		if value, e := expandInt(v); !e {
      out.CacheMaxSize = value
    }
	}

	if v, ok := m["domain"]; ok {
		if value, e := expandString(v); !e {
      out.Domain = value
    }
	}

	if v, ok := m["external_core_file"]; ok {
		if value, e := expandString(v); !e {
      out.ExternalCoreFile = value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["memory_limit"]; ok {
		if value, e := expandQuantity(v); !e {
      out.MemoryLimit = &value
    }
	}

	if v, ok := m["memory_request"]; ok {
		if value, e := expandQuantity(v); !e {
      out.MemoryRequest = &value
    }
	}

	if v, ok := m["provider"]; ok {
		if value, e := expandString(v); !e {
      out.Provider = value
    }
	}

	if v, ok := m["replicas"]; ok {
		if value, e := expandInt(v); !e {
      out.Replicas = value
    }
	}

	if v, ok := m["server_ip"]; ok {
		if value, e := expandString(v); !e {
      out.ServerIP = value
    }
	}

	if v, ok := m["stub_domains"]; ok {
		if value, e := expandStringSliceMap(v); !e {
      out.StubDomains = value
    }
	}

	if v, ok := m["upstream_nameservers"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.UpstreamNameservers = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandKubeProxyConfig(in interface{}) (kops.KubeProxyConfig, bool) {
	d := in.([]interface{})
	out := kops.KubeProxyConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["bind_address"]; ok {
		if value, e := expandString(v); !e {
      out.BindAddress = value
    }
	}

	if v, ok := m["cpu_limit"]; ok {
		if value, e := expandString(v); !e {
      out.CPULimit = value
    }
	}

	if v, ok := m["cpu_request"]; ok {
		if value, e := expandString(v); !e {
      out.CPURequest = value
    }
	}

	if v, ok := m["cluster_cidr"]; ok {
		if value, e := expandString(v); !e {
      out.ClusterCIDR = value
    }
	}

	if v, ok := m["conntrack_max_per_core"]; ok {
		if value, e := expandInt32(v); !e {
      out.ConntrackMaxPerCore = &value
    }
	}

	if v, ok := m["conntrack_min"]; ok {
		if value, e := expandInt32(v); !e {
      out.ConntrackMin = &value
    }
	}

	if v, ok := m["enabled"]; ok {
		if value, e := expandBool(v); !e {
      out.Enabled = &value
    }
	}

	if v, ok := m["feature_gates"]; ok {
		if value, e := expandStringMap(v); !e {
      out.FeatureGates = value
    }
	}

	if v, ok := m["hostname_override"]; ok {
		if value, e := expandString(v); !e {
      out.HostnameOverride = value
    }
	}

	if v, ok := m["ipvs_exclude_cidrs"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.IPVSExcludeCIDRS = value
    }
	}

	if v, ok := m["ipvs_min_sync_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.IPVSMinSyncPeriod = &value
    }
	}

	if v, ok := m["ipvs_scheduler"]; ok {
		if value, e := expandString(v); !e {
      out.IPVSScheduler = &value
    }
	}

	if v, ok := m["ipvs_sync_period"]; ok {
		if value, e := expandDuration(v); !e {
      out.IPVSSyncPeriod = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandInt32(v); !e {
      out.LogLevel = value
    }
	}

	if v, ok := m["master"]; ok {
		if value, e := expandString(v); !e {
      out.Master = value
    }
	}

	if v, ok := m["memory_limit"]; ok {
		if value, e := expandString(v); !e {
      out.MemoryLimit = value
    }
	}

	if v, ok := m["memory_request"]; ok {
		if value, e := expandString(v); !e {
      out.MemoryRequest = value
    }
	}

	if v, ok := m["metrics_bind_address"]; ok {
		if value, e := expandString(v); !e {
      out.MetricsBindAddress = &value
    }
	}

	if v, ok := m["proxy_mode"]; ok {
		if value, e := expandString(v); !e {
      out.ProxyMode = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandKubeSchedulerConfig(in interface{}) (kops.KubeSchedulerConfig, bool) {
	d := in.([]interface{})
	out := kops.KubeSchedulerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["feature_gates"]; ok {
		if value, e := expandStringMap(v); !e {
      out.FeatureGates = value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["leader_election"]; ok {
		if value, e := expandLeaderElectionConfiguration(v); !e {
      out.LeaderElection = &value
    }
	}

	if v, ok := m["log_level"]; ok {
		if value, e := expandInt32(v); !e {
      out.LogLevel = value
    }
	}

	if v, ok := m["master"]; ok {
		if value, e := expandString(v); !e {
      out.Master = value
    }
	}

	if v, ok := m["max_persistent_volumes"]; ok {
		if value, e := expandInt32(v); !e {
      out.MaxPersistentVolumes = &value
    }
	}

	if v, ok := m["use_policy_config_map"]; ok {
		if value, e := expandBool(v); !e {
      out.UsePolicyConfigMap = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandKubenetNetworkingSpec(in interface{}) (kops.KubenetNetworkingSpec, bool) {
	out := kops.KubenetNetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandKuberouterNetworkingSpec(in interface{}) (kops.KuberouterNetworkingSpec, bool) {
	out := kops.KuberouterNetworkingSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandLeaderElectionConfiguration(in interface{}) (kops.LeaderElectionConfiguration, bool) {
	d := in.([]interface{})
	out := kops.LeaderElectionConfiguration{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["leader_elect"]; ok {
		if value, e := expandBool(v); !e {
      out.LeaderElect = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandListMeta(in interface{}) (v1.ListMeta, bool) {
	d := in.([]interface{})
	out := v1.ListMeta{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["continue"]; ok {
		if value, e := expandString(v); !e {
      out.Continue = value
    }
	}

	if v, ok := m["remaining_item_count"]; ok {
		if value, e := expandInt64(v); !e {
      out.RemainingItemCount = &value
    }
	}

	if v, ok := m["resource_version"]; ok {
		if value, e := expandString(v); !e {
      out.ResourceVersion = value
    }
	}

	if v, ok := m["self_link"]; ok {
		if value, e := expandString(v); !e {
      out.SelfLink = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandLoadBalancerAccessSpec(in interface{}) (kops.LoadBalancerAccessSpec, bool) {
	d := in.([]interface{})
	out := kops.LoadBalancerAccessSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["additional_security_groups"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.AdditionalSecurityGroups = value
    }
	}

	if v, ok := m["cross_zone_load_balancing"]; ok {
		if value, e := expandBool(v); !e {
      out.CrossZoneLoadBalancing = &value
    }
	}

	if v, ok := m["idle_timeout_seconds"]; ok {
		if value, e := expandInt64(v); !e {
      out.IdleTimeoutSeconds = &value
    }
	}

	if v, ok := m["ssl_certificate"]; ok {
		if value, e := expandString(v); !e {
      out.SSLCertificate = value
    }
	}

	if v, ok := m["security_group_override"]; ok {
		if value, e := expandString(v); !e {
      out.SecurityGroupOverride = &value
    }
	}

	if v, ok := m["type"]; ok {
		if value, e := expandLoadBalancerType(v); !e {
      out.Type = value
    }
	}

	if v, ok := m["use_for_internal_api"]; ok {
		if value, e := expandBool(v); !e {
      out.UseForInternalApi = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandLoadBalancerType(in interface{}) (kops.LoadBalancerType, bool) {
	d := in.(string)
	r := kops.LoadBalancerType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandLyftVPCNetworkingSpec(in interface{}) (kops.LyftVPCNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.LyftVPCNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["subnet_tags"]; ok {
		if value, e := expandStringMap(v); !e {
      out.SubnetTags = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandManagedFieldsOperationType(in interface{}) (v1.ManagedFieldsOperationType, bool) {
	d := in.(string)
	r := v1.ManagedFieldsOperationType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandNetworkingSpec(in interface{}) (kops.NetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.NetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["amazonvpc"]; ok {
		if value, e := expandAmazonVPCNetworkingSpec(v); !e {
      out.AmazonVPC = &value
    }
	}

	if v, ok := m["cni"]; ok {
		if value, e := expandCNINetworkingSpec(v); !e {
      out.CNI = &value
    }
	}

	if v, ok := m["calico"]; ok {
		if value, e := expandCalicoNetworkingSpec(v); !e {
      out.Calico = &value
    }
	}

	if v, ok := m["canal"]; ok {
		if value, e := expandCanalNetworkingSpec(v); !e {
      out.Canal = &value
    }
	}

	if v, ok := m["cilium"]; ok {
		if value, e := expandCiliumNetworkingSpec(v); !e {
      out.Cilium = &value
    }
	}

	if v, ok := m["classic"]; ok {
		if value, e := expandClassicNetworkingSpec(v); !e {
      out.Classic = &value
    }
	}

	if v, ok := m["external"]; ok {
		if value, e := expandExternalNetworkingSpec(v); !e {
      out.External = &value
    }
	}

	if v, ok := m["flannel"]; ok {
		if value, e := expandFlannelNetworkingSpec(v); !e {
      out.Flannel = &value
    }
	}

	if v, ok := m["gce"]; ok {
		if value, e := expandGCENetworkingSpec(v); !e {
      out.GCE = &value
    }
	}

	if v, ok := m["kopeio"]; ok {
		if value, e := expandKopeioNetworkingSpec(v); !e {
      out.Kopeio = &value
    }
	}

	if v, ok := m["kubenet"]; ok {
		if value, e := expandKubenetNetworkingSpec(v); !e {
      out.Kubenet = &value
    }
	}

	if v, ok := m["kuberouter"]; ok {
		if value, e := expandKuberouterNetworkingSpec(v); !e {
      out.Kuberouter = &value
    }
	}

	if v, ok := m["lyftvpc"]; ok {
		if value, e := expandLyftVPCNetworkingSpec(v); !e {
      out.LyftVPC = &value
    }
	}

	if v, ok := m["romana"]; ok {
		if value, e := expandRomanaNetworkingSpec(v); !e {
      out.Romana = &value
    }
	}

	if v, ok := m["weave"]; ok {
		if value, e := expandWeaveNetworkingSpec(v); !e {
      out.Weave = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandNodeAuthorizationSpec(in interface{}) (kops.NodeAuthorizationSpec, bool) {
	d := in.([]interface{})
	out := kops.NodeAuthorizationSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["node_authorizer"]; ok {
		if value, e := expandNodeAuthorizerSpec(v); !e {
      out.NodeAuthorizer = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandNodeAuthorizerSpec(in interface{}) (kops.NodeAuthorizerSpec, bool) {
	d := in.([]interface{})
	out := kops.NodeAuthorizerSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["authorizer"]; ok {
		if value, e := expandString(v); !e {
      out.Authorizer = value
    }
	}

	if v, ok := m["features"]; ok {
		if value, e := expandStringSlice(v); !e {
      out.Features = &value
    }
	}

	if v, ok := m["image"]; ok {
		if value, e := expandString(v); !e {
      out.Image = value
    }
	}

	if v, ok := m["interval"]; ok {
		if value, e := expandDuration(v); !e {
      out.Interval = &value
    }
	}

	if v, ok := m["node_url"]; ok {
		if value, e := expandString(v); !e {
      out.NodeURL = value
    }
	}

	if v, ok := m["port"]; ok {
		if value, e := expandInt(v); !e {
      out.Port = value
    }
	}

	if v, ok := m["timeout"]; ok {
		if value, e := expandDuration(v); !e {
      out.Timeout = &value
    }
	}

	if v, ok := m["token_ttl"]; ok {
		if value, e := expandDuration(v); !e {
      out.TokenTTL = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandOpenstackBlockStorageConfig(in interface{}) (kops.OpenstackBlockStorageConfig, bool) {
	d := in.([]interface{})
	out := kops.OpenstackBlockStorageConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["ignore_volume_az"]; ok {
		if value, e := expandBool(v); !e {
      out.IgnoreAZ = &value
    }
	}

	if v, ok := m["override_volume_az"]; ok {
		if value, e := expandString(v); !e {
      out.OverrideAZ = &value
    }
	}

	if v, ok := m["bs_version"]; ok {
		if value, e := expandString(v); !e {
      out.Version = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandOpenstackConfiguration(in interface{}) (kops.OpenstackConfiguration, bool) {
	d := in.([]interface{})
	out := kops.OpenstackConfiguration{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["block_storage"]; ok {
		if value, e := expandOpenstackBlockStorageConfig(v); !e {
      out.BlockStorage = &value
    }
	}

	if v, ok := m["insecure_skip_verify"]; ok {
		if value, e := expandBool(v); !e {
      out.InsecureSkipVerify = &value
    }
	}

	if v, ok := m["loadbalancer"]; ok {
		if value, e := expandOpenstackLoadbalancerConfig(v); !e {
      out.Loadbalancer = &value
    }
	}

	if v, ok := m["monitor"]; ok {
		if value, e := expandOpenstackMonitor(v); !e {
      out.Monitor = &value
    }
	}

	if v, ok := m["router"]; ok {
		if value, e := expandOpenstackRouter(v); !e {
      out.Router = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandOpenstackLoadbalancerConfig(in interface{}) (kops.OpenstackLoadbalancerConfig, bool) {
	d := in.([]interface{})
	out := kops.OpenstackLoadbalancerConfig{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["floating_network"]; ok {
		if value, e := expandString(v); !e {
      out.FloatingNetwork = &value
    }
	}

	if v, ok := m["floating_network_id"]; ok {
		if value, e := expandString(v); !e {
      out.FloatingNetworkID = &value
    }
	}

	if v, ok := m["floating_subnet"]; ok {
		if value, e := expandString(v); !e {
      out.FloatingSubnet = &value
    }
	}

	if v, ok := m["manage_security_groups"]; ok {
		if value, e := expandBool(v); !e {
      out.ManageSecGroups = &value
    }
	}

	if v, ok := m["method"]; ok {
		if value, e := expandString(v); !e {
      out.Method = &value
    }
	}

	if v, ok := m["provider"]; ok {
		if value, e := expandString(v); !e {
      out.Provider = &value
    }
	}

	if v, ok := m["subnet_id"]; ok {
		if value, e := expandString(v); !e {
      out.SubnetID = &value
    }
	}

	if v, ok := m["use_octavia"]; ok {
		if value, e := expandBool(v); !e {
      out.UseOctavia = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandOpenstackMonitor(in interface{}) (kops.OpenstackMonitor, bool) {
	d := in.([]interface{})
	out := kops.OpenstackMonitor{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["delay"]; ok {
		if value, e := expandString(v); !e {
      out.Delay = &value
    }
	}

	if v, ok := m["max_retries"]; ok {
		if value, e := expandInt(v); !e {
      out.MaxRetries = &value
    }
	}

	if v, ok := m["timeout"]; ok {
		if value, e := expandString(v); !e {
      out.Timeout = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandOpenstackRouter(in interface{}) (kops.OpenstackRouter, bool) {
	d := in.([]interface{})
	out := kops.OpenstackRouter{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["dns_servers"]; ok {
		if value, e := expandString(v); !e {
      out.DNSServers = &value
    }
	}

	if v, ok := m["external_network"]; ok {
		if value, e := expandString(v); !e {
      out.ExternalNetwork = &value
    }
	}

	if v, ok := m["external_subnet"]; ok {
		if value, e := expandString(v); !e {
      out.ExternalSubnet = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandRBACAuthorizationSpec(in interface{}) (kops.RBACAuthorizationSpec, bool) {
	out := kops.RBACAuthorizationSpec{}
	
	if isEmpty(out) {
		return out, true
	}

	return out, false
}

func expandRomanaNetworkingSpec(in interface{}) (kops.RomanaNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.RomanaNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["daemon_service_ip"]; ok {
		if value, e := expandString(v); !e {
      out.DaemonServiceIP = value
    }
	}

	if v, ok := m["etcd_service_ip"]; ok {
		if value, e := expandString(v); !e {
      out.EtcdServiceIP = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandStatus(in interface{}) (v1.Status, bool) {
	d := in.([]interface{})
	out := v1.Status{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["code"]; ok {
		if value, e := expandInt32(v); !e {
      out.Code = value
    }
	}

	if v, ok := m["details"]; ok {
		if value, e := expandStatusDetails(v); !e {
      out.Details = &value
    }
	}

	if v, ok := m["metadata"]; ok {
		if value, e := expandListMeta(v); !e {
      out.ListMeta = value
    }
	}

	if v, ok := m["message"]; ok {
		if value, e := expandString(v); !e {
      out.Message = value
    }
	}

	if v, ok := m["reason"]; ok {
		if value, e := expandStatusReason(v); !e {
      out.Reason = value
    }
	}

	if v, ok := m["status"]; ok {
		if value, e := expandString(v); !e {
      out.Status = value
    }
	}

	{
		if value, e := expandTypeMeta(in); !e {
      out.TypeMeta = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandStatusCauseSlice(in interface{}) ([]v1.StatusCause, bool) {
	d := in.([]interface{})
	out := make([]v1.StatusCause , len(d))

  if len(d) < 1 {
    return out, true
  }

	for i := 0; i < len(d); i++ {
		out[i] = v1.StatusCause{}

		if v, ok := d[i].(map[string]interface{})["field"]; ok {
      if value, e := expandString(v); !e {
        out[i].Field = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["message"]; ok {
      if value, e := expandString(v); !e {
        out[i].Message = value
      }
		}

		if v, ok := d[i].(map[string]interface{})["reason"]; ok {
      if value, e := expandCauseType(v); !e {
        out[i].Type = value
      }
		}
	}

	return out, false
}

func expandStatusDetails(in interface{}) (v1.StatusDetails, bool) {
	d := in.([]interface{})
	out := v1.StatusDetails{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["causes"]; ok {
		if value, e := expandStatusCauseSlice(v); !e {
      out.Causes = value
    }
	}

	if v, ok := m["group"]; ok {
		if value, e := expandString(v); !e {
      out.Group = value
    }
	}

	if v, ok := m["kind"]; ok {
		if value, e := expandString(v); !e {
      out.Kind = value
    }
	}

	if v, ok := m["name"]; ok {
		if value, e := expandString(v); !e {
      out.Name = value
    }
	}

	if v, ok := m["retry_after_seconds"]; ok {
		if value, e := expandInt32(v); !e {
      out.RetryAfterSeconds = value
    }
	}

	if v, ok := m["uid"]; ok {
		if value, e := expandUID(v); !e {
      out.UID = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandStatusReason(in interface{}) (v1.StatusReason, bool) {
	d := in.(string)
	r := v1.StatusReason(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandStringSliceMap(in interface{}) (map[string][]string, bool) {
	out := make(map[string][]string)
  d := in.(map[string]interface{})
  
  if len(d) < 1 {
    return out, true
  }

	for k, v := range d {
			l := v.([]interface{})
			out[k] = make([]string, len(l))
			for i := range l {
				 out[k][i] = l[i].(string)
			}
	}

	return out, false
}

func expandSubnetType(in interface{}) (kops.SubnetType, bool) {
	d := in.(string)
	r := kops.SubnetType(d)
  out := r
  
  if out == "" {
    return out, true
  }

	return out, false
}

func expandTargetSpec(in interface{}) (kops.TargetSpec, bool) {
	d := in.([]interface{})
	out := kops.TargetSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["terraform"]; ok {
		if value, e := expandTerraformSpec(v); !e {
      out.Terraform = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandTerraformSpec(in interface{}) (kops.TerraformSpec, bool) {
	d := in.([]interface{})
	out := kops.TerraformSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["provider_extra_config"]; ok {
		if value, e := expandStringMap(v); !e {
      out.ProviderExtraConfig = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandTopologySpec(in interface{}) (kops.TopologySpec, bool) {
	d := in.([]interface{})
	out := kops.TopologySpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["bastion"]; ok {
		if value, e := expandBastionSpec(v); !e {
      out.Bastion = &value
    }
	}

	if v, ok := m["dns"]; ok {
		if value, e := expandDNSSpec(v); !e {
      out.DNS = &value
    }
	}

	if v, ok := m["masters"]; ok {
		if value, e := expandString(v); !e {
      out.Masters = value
    }
	}

	if v, ok := m["nodes"]; ok {
		if value, e := expandString(v); !e {
      out.Nodes = value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}

func expandUint32(in interface{}) (uint32, bool) {
	d := in.(uint32)
	r := uint32(d)
  out := r
  
  if out == 0 {
    return out, true
  }

	return out, false
}

func expandWeaveNetworkingSpec(in interface{}) (kops.WeaveNetworkingSpec, bool) {
	d := in.([]interface{})
	out := kops.WeaveNetworkingSpec{}

	if len(d) < 1 {
		return out, true
	}

	m := d[0].(map[string]interface{})

	if v, ok := m["conn_limit"]; ok {
		if value, e := expandInt32(v); !e {
      out.ConnLimit = &value
    }
	}

	if v, ok := m["mtu"]; ok {
		if value, e := expandInt32(v); !e {
      out.MTU = &value
    }
	}

	if v, ok := m["net_extra_args"]; ok {
		if value, e := expandString(v); !e {
      out.NetExtraArgs = value
    }
	}

	if v, ok := m["no_masq_local"]; ok {
		if value, e := expandInt32(v); !e {
      out.NoMasqLocal = &value
    }
	}

  if isEmpty(out) {
    return out, true
  }

	return out, false
}
