// Code generated by engine.go; DO NOT EDIT.

package provider

import (
	"k8s.io/kops/pkg/apis/kops"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/api/resource"
)

func expandAccessSpec(in interface{}) *kops.AccessSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.AccessSpec{}

	if v, ok := d["dns"]; ok {
		out.DNS = expandDNSAccessSpec(v)
	}

	if v, ok := d["load_balancer"]; ok {
		out.LoadBalancer = expandLoadBalancerAccessSpec(v)
	}

	return out
}

func expandAddonSpecSlice(in interface{}) []kops.AddonSpec {
	d := in.([]interface{})
	out := make([]kops.AddonSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.AddonSpec{}

		if v, ok := d[i].(map[string]interface{})["manifest"]; ok {
			out[i].Manifest = expandString(v)
		}
	}

	return out
}

func expandAlwaysAllowAuthorizationSpec(in interface{}) *kops.AlwaysAllowAuthorizationSpec {
	out := in.(*kops.AlwaysAllowAuthorizationSpec)

	return out
}

func expandAmazonVPCNetworkingSpec(in interface{}) *kops.AmazonVPCNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.AmazonVPCNetworkingSpec{}

	if v, ok := d["image_name"]; ok {
		out.ImageName = expandString(v)
	}

	return out
}

func expandAssets(in interface{}) *kops.Assets {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.Assets{}

	if v, ok := d["container_proxy"]; ok {
		value := expandString(v)

		out.ContainerProxy = &value
	}

	if v, ok := d["container_registry"]; ok {
		value := expandString(v)

		out.ContainerRegistry = &value
	}

	if v, ok := d["file_repository"]; ok {
		value := expandString(v)

		out.FileRepository = &value
	}

	return out
}

func expandAuthenticationSpec(in interface{}) *kops.AuthenticationSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.AuthenticationSpec{}

	if v, ok := d["aws"]; ok {
		out.Aws = expandAwsAuthenticationSpec(v)
	}

	if v, ok := d["kopeio"]; ok {
		out.Kopeio = expandKopeioAuthenticationSpec(v)
	}

	return out
}

func expandAuthorizationSpec(in interface{}) *kops.AuthorizationSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.AuthorizationSpec{}

	if v, ok := d["always_allow"]; ok {
		out.AlwaysAllow = expandAlwaysAllowAuthorizationSpec(v)
	}

	if v, ok := d["rbac"]; ok {
		out.RBAC = expandRBACAuthorizationSpec(v)
	}

	return out
}

func expandAwsAuthenticationSpec(in interface{}) *kops.AwsAuthenticationSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.AwsAuthenticationSpec{}

	if v, ok := d["cpu_limit"]; ok {
		out.CPULimit = expandQuantity(v)
	}

	if v, ok := d["cpu_request"]; ok {
		out.CPURequest = expandQuantity(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["memory_limit"]; ok {
		out.MemoryLimit = expandQuantity(v)
	}

	if v, ok := d["memory_request"]; ok {
		out.MemoryRequest = expandQuantity(v)
	}

	return out
}

func expandBastionSpec(in interface{}) *kops.BastionSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.BastionSpec{}

	if v, ok := d["bastion_public_name"]; ok {
		out.BastionPublicName = expandString(v)
	}

	if v, ok := d["idle_timeout_seconds"]; ok {
		value := expandInt64(v)

		out.IdleTimeoutSeconds = &value
	}

	return out
}

func expandCNINetworkingSpec(in interface{}) *kops.CNINetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CNINetworkingSpec{}

	if v, ok := d["uses_secondary_ip"]; ok {
		value := expandBool(v)

		out.UsesSecondaryIP = (*value)
	}

	return out
}

func expandCalicoNetworkingSpec(in interface{}) *kops.CalicoNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CalicoNetworkingSpec{}

	if v, ok := d["cross_subnet"]; ok {
		value := expandBool(v)

		out.CrossSubnet = (*value)
	}

	if v, ok := d["ipip_mode"]; ok {
		out.IPIPMode = expandString(v)
	}

	if v, ok := d["log_severity_screen"]; ok {
		out.LogSeverityScreen = expandString(v)
	}

	if v, ok := d["mtu"]; ok {
		value := expandInt32(v)

		out.MTU = &value
	}

	if v, ok := d["major_version"]; ok {
		out.MajorVersion = expandString(v)
	}

	if v, ok := d["prometheus_go_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusGoMetricsEnabled = (*value)
	}

	if v, ok := d["prometheus_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusMetricsEnabled = (*value)
	}

	if v, ok := d["prometheus_metrics_port"]; ok {
		out.PrometheusMetricsPort = expandInt32(v)
	}

	if v, ok := d["prometheus_process_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusProcessMetricsEnabled = (*value)
	}

	if v, ok := d["typha_prometheus_metrics_enabled"]; ok {
		value := expandBool(v)

		out.TyphaPrometheusMetricsEnabled = (*value)
	}

	if v, ok := d["typha_prometheus_metrics_port"]; ok {
		out.TyphaPrometheusMetricsPort = expandInt32(v)
	}

	if v, ok := d["typha_replicas"]; ok {
		out.TyphaReplicas = expandInt32(v)
	}

	return out
}

func expandCanalNetworkingSpec(in interface{}) *kops.CanalNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CanalNetworkingSpec{}

	if v, ok := d["chain_insert_mode"]; ok {
		out.ChainInsertMode = expandString(v)
	}

	if v, ok := d["default_endpoint_to_host_action"]; ok {
		out.DefaultEndpointToHostAction = expandString(v)
	}

	if v, ok := d["disable_flannel_forward_rules"]; ok {
		value := expandBool(v)

		out.DisableFlannelForwardRules = (*value)
	}

	if v, ok := d["log_severity_sys"]; ok {
		out.LogSeveritySys = expandString(v)
	}

	if v, ok := d["mtu"]; ok {
		value := expandInt32(v)

		out.MTU = &value
	}

	if v, ok := d["prometheus_go_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusGoMetricsEnabled = (*value)
	}

	if v, ok := d["prometheus_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusMetricsEnabled = (*value)
	}

	if v, ok := d["prometheus_metrics_port"]; ok {
		out.PrometheusMetricsPort = expandInt32(v)
	}

	if v, ok := d["prometheus_process_metrics_enabled"]; ok {
		value := expandBool(v)

		out.PrometheusProcessMetricsEnabled = (*value)
	}

	return out
}

func expandCauseType(in interface{}) v1.CauseType {
	out := in.(v1.CauseType)

	return out
}

func expandCiliumNetworkingSpec(in interface{}) *kops.CiliumNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CiliumNetworkingSpec{}

	if v, ok := d["access_log"]; ok {
		out.AccessLog = expandString(v)
	}

	if v, ok := d["agent_labels"]; ok {
		out.AgentLabels = expandStringSlice(v)
	}

	if v, ok := d["allow_localhost"]; ok {
		out.AllowLocalhost = expandString(v)
	}

	{
		value := expandBool(d["auto_direct_node_routes"])

		out.AutoDirectNodeRoutes = (*value)
	}

	if v, ok := d["auto_ipv_6node_routes"]; ok {
		value := expandBool(v)

		out.AutoIpv6NodeRoutes = (*value)
	}

	{
		out.BPFCTGlobalAnyMax = expandInt(d["bpf_ct_global_any_max"])
	}

	{
		out.BPFCTGlobalTCPMax = expandInt(d["bpf_ct_global_tcp_max"])
	}

	if v, ok := d["bpf_root"]; ok {
		out.BPFRoot = expandString(v)
	}

	{
		out.ClusterName = expandString(d["cluster_name"])
	}

	{
		out.CniBinPath = expandString(d["cni_bin_path"])
	}

	if v, ok := d["container_runtime"]; ok {
		out.ContainerRuntime = expandStringSlice(v)
	}

	if v, ok := d["container_runtime_endpoint"]; ok {
		out.ContainerRuntimeEndpoint = expandStringMap(v)
	}

	if v, ok := d["container_runtime_labels"]; ok {
		out.ContainerRuntimeLabels = expandString(v)
	}

	if v, ok := d["debug"]; ok {
		value := expandBool(v)

		out.Debug = (*value)
	}

	if v, ok := d["debug_verbose"]; ok {
		out.DebugVerbose = expandStringSlice(v)
	}

	if v, ok := d["device"]; ok {
		out.Device = expandString(v)
	}

	if v, ok := d["disable_conntrack"]; ok {
		value := expandBool(v)

		out.DisableConntrack = (*value)
	}

	if v, ok := d["disable_ipv_4"]; ok {
		value := expandBool(v)

		out.DisableIpv4 = (*value)
	}

	if v, ok := d["disable_k8s_services"]; ok {
		value := expandBool(v)

		out.DisableK8sServices = (*value)
	}

	if v, ok := d["disable_masquerade"]; ok {
		value := expandBool(v)

		out.DisableMasquerade = (*value)
	}

	{
		value := expandBool(d["enableipv_4"])

		out.EnableIpv4 = (*value)
	}

	{
		value := expandBool(d["enableipv_6"])

		out.EnableIpv6 = (*value)
	}

	{
		value := expandBool(d["enable_node_port"])

		out.EnableNodePort = (*value)
	}

	if v, ok := d["enable_policy"]; ok {
		out.EnablePolicy = expandString(v)
	}

	if v, ok := d["enable_tracing"]; ok {
		value := expandBool(v)

		out.EnableTracing = (*value)
	}

	if v, ok := d["envoy_log"]; ok {
		out.EnvoyLog = expandString(v)
	}

	{
		value := expandBool(d["ip_tables_rules_noinstall"])

		out.IPTablesRulesNoinstall = (*value)
	}

	if v, ok := d["ipv_4cluster_cidr_mask_size"]; ok {
		out.Ipv4ClusterCIDRMaskSize = expandInt(v)
	}

	if v, ok := d["ipv_4node"]; ok {
		out.Ipv4Node = expandString(v)
	}

	if v, ok := d["ipv_4range"]; ok {
		out.Ipv4Range = expandString(v)
	}

	if v, ok := d["ipv_4service_range"]; ok {
		out.Ipv4ServiceRange = expandString(v)
	}

	if v, ok := d["ipv_6cluster_alloc_cidr"]; ok {
		out.Ipv6ClusterAllocCidr = expandString(v)
	}

	if v, ok := d["ipv_6node"]; ok {
		out.Ipv6Node = expandString(v)
	}

	if v, ok := d["ipv_6range"]; ok {
		out.Ipv6Range = expandString(v)
	}

	if v, ok := d["ipv_6service_range"]; ok {
		out.Ipv6ServiceRange = expandString(v)
	}

	if v, ok := d["k_8s_api_server"]; ok {
		out.K8sAPIServer = expandString(v)
	}

	if v, ok := d["k_8s_kubeconfig_path"]; ok {
		out.K8sKubeconfigPath = expandString(v)
	}

	if v, ok := d["keep_bpf_templates"]; ok {
		value := expandBool(v)

		out.KeepBPFTemplates = (*value)
	}

	if v, ok := d["keep_config"]; ok {
		value := expandBool(v)

		out.KeepConfig = (*value)
	}

	if v, ok := d["lb"]; ok {
		out.LB = expandString(v)
	}

	if v, ok := d["label_prefix_file"]; ok {
		out.LabelPrefixFile = expandString(v)
	}

	if v, ok := d["labels"]; ok {
		out.Labels = expandStringSlice(v)
	}

	if v, ok := d["lib_dir"]; ok {
		out.LibDir = expandString(v)
	}

	if v, ok := d["log_driver"]; ok {
		out.LogDrivers = expandStringSlice(v)
	}

	if v, ok := d["log_opt"]; ok {
		out.LogOpt = expandStringMap(v)
	}

	if v, ok := d["logstash"]; ok {
		value := expandBool(v)

		out.Logstash = (*value)
	}

	if v, ok := d["logstash_agent"]; ok {
		out.LogstashAgent = expandString(v)
	}

	if v, ok := d["logstash_probe_timer"]; ok {
		out.LogstashProbeTimer = expandUint32(v)
	}

	{
		out.MonitorAggregation = expandString(d["monitor_aggregation"])
	}

	if v, ok := d["nat_46range"]; ok {
		out.Nat46Range = expandString(v)
	}

	{
		out.NodeInitBootstrapFile = expandString(d["node_init_bootstrap_file"])
	}

	if v, ok := d["pprof"]; ok {
		value := expandBool(v)

		out.Pprof = (*value)
	}

	{
		value := expandBool(d["preallocate_bpf_maps"])

		out.PreallocateBPFMaps = (*value)
	}

	if v, ok := d["prefilter_device"]; ok {
		out.PrefilterDevice = expandString(v)
	}

	if v, ok := d["prometheus_serve_addr"]; ok {
		out.PrometheusServeAddr = expandString(v)
	}

	{
		value := expandBool(d["reconfigure_kubelet"])

		out.ReconfigureKubelet = (*value)
	}

	{
		value := expandBool(d["remove_cbr_bridge"])

		out.RemoveCbrBridge = (*value)
	}

	{
		value := expandBool(d["restart_pods"])

		out.RestartPods = (*value)
	}

	if v, ok := d["restore"]; ok {
		value := expandBool(v)

		out.Restore = (*value)
	}

	{
		out.SidecarIstioProxyImage = expandString(d["sidecar_istio_proxy_image"])
	}

	if v, ok := d["single_cluster_route"]; ok {
		value := expandBool(v)

		out.SingleClusterRoute = (*value)
	}

	if v, ok := d["socket_path"]; ok {
		out.SocketPath = expandString(v)
	}

	if v, ok := d["state_dir"]; ok {
		out.StateDir = expandString(v)
	}

	{
		value := expandBool(d["to_fqdns_enable_poller"])

		out.ToFqdnsEnablePoller = (*value)
	}

	if v, ok := d["trace_payloadlen"]; ok {
		out.TracePayloadLen = expandInt(v)
	}

	if v, ok := d["tunnel"]; ok {
		out.Tunnel = expandString(v)
	}

	if v, ok := d["version"]; ok {
		out.Version = expandString(v)
	}

	return out
}

func expandClassicNetworkingSpec(in interface{}) *kops.ClassicNetworkingSpec {
	out := in.(*kops.ClassicNetworkingSpec)

	return out
}

func expandCloudConfiguration(in interface{}) *kops.CloudConfiguration {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CloudConfiguration{}

	if v, ok := d["disable_security_group_ingress"]; ok {
		out.DisableSecurityGroupIngress = expandBool(v)
	}

	if v, ok := d["elb_security_group"]; ok {
		value := expandString(v)

		out.ElbSecurityGroup = &value
	}

	if v, ok := d["multizone"]; ok {
		out.Multizone = expandBool(v)
	}

	if v, ok := d["node_instance_prefix"]; ok {
		value := expandString(v)

		out.NodeInstancePrefix = &value
	}

	if v, ok := d["node_tags"]; ok {
		value := expandString(v)

		out.NodeTags = &value
	}

	if v, ok := d["openstack"]; ok {
		out.Openstack = expandOpenstackConfiguration(v)
	}

	if v, ok := d["spotinst_orientation"]; ok {
		value := expandString(v)

		out.SpotinstOrientation = &value
	}

	if v, ok := d["spotinst_product"]; ok {
		value := expandString(v)

		out.SpotinstProduct = &value
	}

	if v, ok := d["v_sphere_core_dns_server"]; ok {
		value := expandString(v)

		out.VSphereCoreDNSServer = &value
	}

	if v, ok := d["v_sphere_datacenter"]; ok {
		value := expandString(v)

		out.VSphereDatacenter = &value
	}

	if v, ok := d["v_sphere_datastore"]; ok {
		value := expandString(v)

		out.VSphereDatastore = &value
	}

	if v, ok := d["v_sphere_password"]; ok {
		value := expandString(v)

		out.VSpherePassword = &value
	}

	if v, ok := d["v_sphere_resource_pool"]; ok {
		value := expandString(v)

		out.VSphereResourcePool = &value
	}

	if v, ok := d["v_sphere_server"]; ok {
		value := expandString(v)

		out.VSphereServer = &value
	}

	if v, ok := d["v_sphere_username"]; ok {
		value := expandString(v)

		out.VSphereUsername = &value
	}

	return out
}

func expandCloudControllerManagerConfig(in interface{}) *kops.CloudControllerManagerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.CloudControllerManagerConfig{}

	if v, ok := d["allocate_node_cid_rss"]; ok {
		out.AllocateNodeCIDRs = expandBool(v)
	}

	if v, ok := d["cidr_allocator_type"]; ok {
		value := expandString(v)

		out.CIDRAllocatorType = &value
	}

	if v, ok := d["cloud_provider"]; ok {
		out.CloudProvider = expandString(v)
	}

	if v, ok := d["cluster_cidr"]; ok {
		out.ClusterCIDR = expandString(v)
	}

	if v, ok := d["cluster_name"]; ok {
		out.ClusterName = expandString(v)
	}

	if v, ok := d["configure_cloud_routes"]; ok {
		out.ConfigureCloudRoutes = expandBool(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["leader_election"]; ok {
		out.LeaderElection = expandLeaderElectionConfiguration(v)
	}

	if v, ok := d["log_level"]; ok {
		out.LogLevel = expandInt32(v)
	}

	if v, ok := d["master"]; ok {
		out.Master = expandString(v)
	}

	if v, ok := d["use_service_account_credentials"]; ok {
		out.UseServiceAccountCredentials = expandBool(v)
	}

	return out
}

func expandClusterSpec(in interface{}) kops.ClusterSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := kops.ClusterSpec{}

	if v, ok := d["api"]; ok {
		out.API = expandAccessSpec(v)
	}

	if v, ok := d["additional_network_cid_rss"]; ok {
		out.AdditionalNetworkCIDRs = expandStringSlice(v)
	}

	if v, ok := d["additional_policies"]; ok {
		value := expandStringMap(v)

		out.AdditionalPolicies = &value
	}

	if v, ok := d["additional_sans"]; ok {
		out.AdditionalSANs = expandStringSlice(v)
	}

	if v, ok := d["addons"]; ok {
		out.Addons = expandAddonSpecSlice(v)
	}

	if v, ok := d["assets"]; ok {
		out.Assets = expandAssets(v)
	}

	if v, ok := d["authentication"]; ok {
		out.Authentication = expandAuthenticationSpec(v)
	}

	if v, ok := d["authorization"]; ok {
		out.Authorization = expandAuthorizationSpec(v)
	}

	if v, ok := d["channel"]; ok {
		out.Channel = expandString(v)
	}

	if v, ok := d["cloud_config"]; ok {
		out.CloudConfig = expandCloudConfiguration(v)
	}

	if v, ok := d["cloud_labels"]; ok {
		out.CloudLabels = expandStringMap(v)
	}

	if v, ok := d["cloud_provider"]; ok {
		out.CloudProvider = expandString(v)
	}

	if v, ok := d["cluster_dns_domain"]; ok {
		out.ClusterDNSDomain = expandString(v)
	}

	if v, ok := d["config_base"]; ok {
		out.ConfigBase = expandString(v)
	}

	if v, ok := d["config_store"]; ok {
		out.ConfigStore = expandString(v)
	}

	if v, ok := d["dns_zone"]; ok {
		out.DNSZone = expandString(v)
	}

	if v, ok := d["disable_subnet_tags"]; ok {
		value := expandBool(v)

		out.DisableSubnetTags = (*value)
	}

	if v, ok := d["docker"]; ok {
		out.Docker = expandDockerConfig(v)
	}

	if v, ok := d["egress_proxy"]; ok {
		out.EgressProxy = expandEgressProxySpec(v)
	}

	if v, ok := d["encryption_config"]; ok {
		out.EncryptionConfig = expandBool(v)
	}

	if v, ok := d["etcd_clusters"]; ok {
		out.EtcdClusters = expandEtcdClusterSpecSlice(v)
	}

	if v, ok := d["cloud_controller_manager"]; ok {
		out.ExternalCloudControllerManager = expandCloudControllerManagerConfig(v)
	}

	if v, ok := d["external_dns"]; ok {
		out.ExternalDNS = expandExternalDNSConfig(v)
	}

	if v, ok := d["file_assets"]; ok {
		out.FileAssets = expandFileAssetSpecSlice(v)
	}

	if v, ok := d["hooks"]; ok {
		out.Hooks = expandHookSpecSlice(v)
	}

	if v, ok := d["iam"]; ok {
		out.IAM = expandIAMSpec(v)
	}

	if v, ok := d["isolate_masters"]; ok {
		out.IsolateMasters = expandBool(v)
	}

	if v, ok := d["key_store"]; ok {
		out.KeyStore = expandString(v)
	}

	if v, ok := d["kube_api_server"]; ok {
		out.KubeAPIServer = expandKubeAPIServerConfig(v)
	}

	if v, ok := d["kube_controller_manager"]; ok {
		out.KubeControllerManager = expandKubeControllerManagerConfig(v)
	}

	if v, ok := d["kube_dns"]; ok {
		out.KubeDNS = expandKubeDNSConfig(v)
	}

	if v, ok := d["kube_proxy"]; ok {
		out.KubeProxy = expandKubeProxyConfig(v)
	}

	if v, ok := d["kube_scheduler"]; ok {
		out.KubeScheduler = expandKubeSchedulerConfig(v)
	}

	if v, ok := d["kubelet"]; ok {
		out.Kubelet = expandKubeletConfigSpec(v)
	}

	if v, ok := d["kubernetes_api_access"]; ok {
		out.KubernetesAPIAccess = expandStringSlice(v)
	}

	if v, ok := d["kubernetes_version"]; ok {
		out.KubernetesVersion = expandString(v)
	}

	if v, ok := d["master_internal_name"]; ok {
		out.MasterInternalName = expandString(v)
	}

	if v, ok := d["master_kubelet"]; ok {
		out.MasterKubelet = expandKubeletConfigSpec(v)
	}

	if v, ok := d["master_public_name"]; ok {
		out.MasterPublicName = expandString(v)
	}

	if v, ok := d["network_cidr"]; ok {
		out.NetworkCIDR = expandString(v)
	}

	if v, ok := d["network_id"]; ok {
		out.NetworkID = expandString(v)
	}

	if v, ok := d["networking"]; ok {
		out.Networking = expandNetworkingSpec(v)
	}

	if v, ok := d["node_authorization"]; ok {
		out.NodeAuthorization = expandNodeAuthorizationSpec(v)
	}

	if v, ok := d["node_port_access"]; ok {
		out.NodePortAccess = expandStringSlice(v)
	}

	if v, ok := d["non_masquerade_cidr"]; ok {
		out.NonMasqueradeCIDR = expandString(v)
	}

	if v, ok := d["pod_cidr"]; ok {
		out.PodCIDR = expandString(v)
	}

	if v, ok := d["project"]; ok {
		out.Project = expandString(v)
	}

	if v, ok := d["ssh_access"]; ok {
		out.SSHAccess = expandStringSlice(v)
	}

	if v, ok := d["ssh_key_name"]; ok {
		out.SSHKeyName = expandString(v)
	}

	if v, ok := d["secret_store"]; ok {
		out.SecretStore = expandString(v)
	}

	if v, ok := d["service_cluster_ip_range"]; ok {
		out.ServiceClusterIPRange = expandString(v)
	}

	if v, ok := d["subnets"]; ok {
		out.Subnets = expandClusterSubnetSpecSlice(v)
	}

	if v, ok := d["target"]; ok {
		out.Target = expandTargetSpec(v)
	}

	if v, ok := d["topology"]; ok {
		out.Topology = expandTopologySpec(v)
	}

	if v, ok := d["update_policy"]; ok {
		value := expandString(v)

		out.UpdatePolicy = &value
	}

	return out
}

func expandClusterSubnetSpecSlice(in interface{}) []kops.ClusterSubnetSpec {
	d := in.([]interface{})
	out := make([]kops.ClusterSubnetSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.ClusterSubnetSpec{}

		if v, ok := d[i].(map[string]interface{})["cidr"]; ok {
			out[i].CIDR = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["egress"]; ok {
			out[i].Egress = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["id"]; ok {
			out[i].ProviderID = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["public_ip"]; ok {
			out[i].PublicIP = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["region"]; ok {
			out[i].Region = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["type"]; ok {
			out[i].Type = expandSubnetType(v)
		}

		if v, ok := d[i].(map[string]interface{})["zone"]; ok {
			out[i].Zone = expandString(v)
		}
	}

	return out
}

func expandDNSAccessSpec(in interface{}) *kops.DNSAccessSpec {
	out := in.(*kops.DNSAccessSpec)

	return out
}

func expandDNSSpec(in interface{}) *kops.DNSSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.DNSSpec{}

	if v, ok := d["type"]; ok {
		out.Type = expandDNSType(v)
	}

	return out
}

func expandDNSType(in interface{}) kops.DNSType {
	out := in.(kops.DNSType)

	return out
}

func expandDockerConfig(in interface{}) *kops.DockerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.DockerConfig{}

	if v, ok := d["authorization_plugins"]; ok {
		out.AuthorizationPlugins = expandStringSlice(v)
	}

	if v, ok := d["bridge"]; ok {
		value := expandString(v)

		out.Bridge = &value
	}

	if v, ok := d["bridge_ip"]; ok {
		value := expandString(v)

		out.BridgeIP = &value
	}

	if v, ok := d["data_root"]; ok {
		value := expandString(v)

		out.DataRoot = &value
	}

	if v, ok := d["default_ulimit"]; ok {
		out.DefaultUlimit = expandStringSlice(v)
	}

	if v, ok := d["exec_opt"]; ok {
		out.ExecOpt = expandStringSlice(v)
	}

	if v, ok := d["exec_root"]; ok {
		value := expandString(v)

		out.ExecRoot = &value
	}

	if v, ok := d["experimental"]; ok {
		out.Experimental = expandBool(v)
	}

	if v, ok := d["hosts"]; ok {
		out.Hosts = expandStringSlice(v)
	}

	if v, ok := d["ip_masq"]; ok {
		out.IPMasq = expandBool(v)
	}

	if v, ok := d["ip_tables"]; ok {
		out.IPTables = expandBool(v)
	}

	if v, ok := d["insecure_registries"]; ok {
		out.InsecureRegistries = expandStringSlice(v)
	}

	if v, ok := d["insecure_registry"]; ok {
		value := expandString(v)

		out.InsecureRegistry = &value
	}

	if v, ok := d["live_restore"]; ok {
		out.LiveRestore = expandBool(v)
	}

	if v, ok := d["log_driver"]; ok {
		value := expandString(v)

		out.LogDriver = &value
	}

	if v, ok := d["log_level"]; ok {
		value := expandString(v)

		out.LogLevel = &value
	}

	if v, ok := d["log_opt"]; ok {
		out.LogOpt = expandStringSlice(v)
	}

	if v, ok := d["mtu"]; ok {
		value := expandInt32(v)

		out.MTU = &value
	}

	if v, ok := d["metrics_address"]; ok {
		value := expandString(v)

		out.MetricsAddress = &value
	}

	if v, ok := d["registry_mirrors"]; ok {
		out.RegistryMirrors = expandStringSlice(v)
	}

	if v, ok := d["skip_install"]; ok {
		value := expandBool(v)

		out.SkipInstall = (*value)
	}

	if v, ok := d["storage"]; ok {
		value := expandString(v)

		out.Storage = &value
	}

	if v, ok := d["storage_opts"]; ok {
		out.StorageOpts = expandStringSlice(v)
	}

	if v, ok := d["user_namespace_remap"]; ok {
		out.UserNamespaceRemap = expandString(v)
	}

	if v, ok := d["version"]; ok {
		value := expandString(v)

		out.Version = &value
	}

	return out
}

func expandEgressProxySpec(in interface{}) *kops.EgressProxySpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.EgressProxySpec{}

	if v, ok := d["http_proxy"]; ok {
		out.HTTPProxy = expandHTTPProxy(v)
	}

	if v, ok := d["excludes"]; ok {
		out.ProxyExcludes = expandString(v)
	}

	return out
}

func expandEtcdBackupSpec(in interface{}) *kops.EtcdBackupSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.EtcdBackupSpec{}

	if v, ok := d["backup_store"]; ok {
		out.BackupStore = expandString(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	return out
}

func expandEtcdClusterSpecSlice(in interface{}) []*kops.EtcdClusterSpec {
	d := in.([]interface{})
	out := make([]*kops.EtcdClusterSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = &kops.EtcdClusterSpec{}

		if v, ok := d[i].(map[string]interface{})["backups"]; ok {
			out[i].Backups = expandEtcdBackupSpec(v)
		}

		if v, ok := d[i].(map[string]interface{})["cpu_request"]; ok {
			out[i].CPURequest = expandQuantity(v)
		}

		if v, ok := d[i].(map[string]interface{})["enable_etcd_tls"]; ok {
			value := expandBool(v)

			out[i].EnableEtcdTLS = (*value)
		}

		if v, ok := d[i].(map[string]interface{})["enable_tls_auth"]; ok {
			value := expandBool(v)

			out[i].EnableTLSAuth = (*value)
		}

		if v, ok := d[i].(map[string]interface{})["heartbeat_interval"]; ok {
			out[i].HeartbeatInterval = expandDuration(v)
		}

		if v, ok := d[i].(map[string]interface{})["image"]; ok {
			out[i].Image = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["leader_election_timeout"]; ok {
			out[i].LeaderElectionTimeout = expandDuration(v)
		}

		if v, ok := d[i].(map[string]interface{})["manager"]; ok {
			out[i].Manager = expandEtcdManagerSpec(v)
		}

		if v, ok := d[i].(map[string]interface{})["etcd_members"]; ok {
			out[i].Members = expandEtcdMemberSpecSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["memory_request"]; ok {
			out[i].MemoryRequest = expandQuantity(v)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["provider"]; ok {
			out[i].Provider = expandEtcdProviderType(v)
		}

		if v, ok := d[i].(map[string]interface{})["version"]; ok {
			out[i].Version = expandString(v)
		}
	}

	return out
}

func expandEtcdManagerSpec(in interface{}) *kops.EtcdManagerSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.EtcdManagerSpec{}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	return out
}

func expandEtcdMemberSpecSlice(in interface{}) []*kops.EtcdMemberSpec {
	d := in.([]interface{})
	out := make([]*kops.EtcdMemberSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = &kops.EtcdMemberSpec{}

		if v, ok := d[i].(map[string]interface{})["encrypted_volume"]; ok {
			out[i].EncryptedVolume = expandBool(v)
		}

		if v, ok := d[i].(map[string]interface{})["instance_group"]; ok {
			value := expandString(v)

			out[i].InstanceGroup = &value
		}

		if v, ok := d[i].(map[string]interface{})["kms_key_id"]; ok {
			value := expandString(v)

			out[i].KmsKeyId = &value
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["volume_iops"]; ok {
			value := expandInt32(v)

			out[i].VolumeIops = &value
		}

		if v, ok := d[i].(map[string]interface{})["volume_size"]; ok {
			value := expandInt32(v)

			out[i].VolumeSize = &value
		}

		if v, ok := d[i].(map[string]interface{})["volume_type"]; ok {
			value := expandString(v)

			out[i].VolumeType = &value
		}
	}

	return out
}

func expandEtcdProviderType(in interface{}) kops.EtcdProviderType {
	out := in.(kops.EtcdProviderType)

	return out
}

func expandExecContainerAction(in interface{}) *kops.ExecContainerAction {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.ExecContainerAction{}

	if v, ok := d["command"]; ok {
		out.Command = expandStringSlice(v)
	}

	if v, ok := d["environment"]; ok {
		out.Environment = expandStringMap(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	return out
}

func expandExternalDNSConfig(in interface{}) *kops.ExternalDNSConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.ExternalDNSConfig{}

	if v, ok := d["disable"]; ok {
		value := expandBool(v)

		out.Disable = (*value)
	}

	if v, ok := d["watch_ingress"]; ok {
		out.WatchIngress = expandBool(v)
	}

	if v, ok := d["watch_namespace"]; ok {
		out.WatchNamespace = expandString(v)
	}

	return out
}

func expandExternalNetworkingSpec(in interface{}) *kops.ExternalNetworkingSpec {
	out := in.(*kops.ExternalNetworkingSpec)

	return out
}

func expandFields(in interface{}) *v1.Fields {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &v1.Fields{}

	{
		out.Map = expandFieldsMap(d)
	}

	return out
}

func expandFieldsMap(in interface{}) map[string]v1.Fields {
	out := in.(map[string]v1.Fields)

	return out
}

func expandFlannelNetworkingSpec(in interface{}) *kops.FlannelNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.FlannelNetworkingSpec{}

	if v, ok := d["backend"]; ok {
		out.Backend = expandString(v)
	}

	if v, ok := d["iptables_resync_seconds"]; ok {
		value := expandInt32(v)

		out.IptablesResyncSeconds = &value
	}

	return out
}

func expandFloat32(in interface{}) *float32 {
	out := in.(*float32)

	return out
}

func expandFloat64(in interface{}) *float64 {
	out := in.(*float64)

	return out
}

func expandFormat(in interface{}) resource.Format {
	out := in.(resource.Format)

	return out
}

func expandGCENetworkingSpec(in interface{}) *kops.GCENetworkingSpec {
	out := in.(*kops.GCENetworkingSpec)

	return out
}

func expandHTTPProxy(in interface{}) kops.HTTPProxy {
	d := in.([]interface{})[0].(map[string]interface{})
	out := kops.HTTPProxy{}

	if v, ok := d["host"]; ok {
		out.Host = expandString(v)
	}

	if v, ok := d["port"]; ok {
		out.Port = expandInt(v)
	}

	return out
}

func expandIAMSpec(in interface{}) *kops.IAMSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.IAMSpec{}

	if v, ok := d["allow_container_registry"]; ok {
		value := expandBool(v)

		out.AllowContainerRegistry = (*value)
	}

	{
		value := expandBool(d["legacy"])

		out.Legacy = (*value)
	}

	return out
}

func expandInitializerSlice(in interface{}) []v1.Initializer {
	d := in.([]interface{})
	out := make([]v1.Initializer , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = v1.Initializer{}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}
	}

	return out
}

func expandInstanceGroupRoleSlice(in interface{}) []kops.InstanceGroupRole {
	d := in.([]interface{})
	out := make([]kops.InstanceGroupRole , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = d[i].(kops.InstanceGroupRole)
	}

	return out
}

func expandInt(in interface{}) int {
	out := in.(int)

	return out
}

func expandKopeioAuthenticationSpec(in interface{}) *kops.KopeioAuthenticationSpec {
	out := in.(*kops.KopeioAuthenticationSpec)

	return out
}

func expandKopeioNetworkingSpec(in interface{}) *kops.KopeioNetworkingSpec {
	out := in.(*kops.KopeioNetworkingSpec)

	return out
}

func expandKubeAPIServerConfig(in interface{}) *kops.KubeAPIServerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeAPIServerConfig{}

	if v, ok := d["api_audiences"]; ok {
		out.APIAudiences = expandStringSlice(v)
	}

	if v, ok := d["api_server_count"]; ok {
		value := expandInt32(v)

		out.APIServerCount = &value
	}

	if v, ok := d["address"]; ok {
		out.Address = expandString(v)
	}

	if v, ok := d["admission_control"]; ok {
		out.AdmissionControl = expandStringSlice(v)
	}

	if v, ok := d["admission_control_config_file"]; ok {
		out.AdmissionControlConfigFile = expandString(v)
	}

	if v, ok := d["allow_privileged"]; ok {
		out.AllowPrivileged = expandBool(v)
	}

	if v, ok := d["anonymous_auth"]; ok {
		out.AnonymousAuth = expandBool(v)
	}

	if v, ok := d["append_admission_plugins"]; ok {
		out.AppendAdmissionPlugins = expandStringSlice(v)
	}

	if v, ok := d["audit_log_format"]; ok {
		value := expandString(v)

		out.AuditLogFormat = &value
	}

	if v, ok := d["audit_log_max_age"]; ok {
		value := expandInt32(v)

		out.AuditLogMaxAge = &value
	}

	if v, ok := d["audit_log_max_backups"]; ok {
		value := expandInt32(v)

		out.AuditLogMaxBackups = &value
	}

	if v, ok := d["audit_log_max_size"]; ok {
		value := expandInt32(v)

		out.AuditLogMaxSize = &value
	}

	if v, ok := d["audit_log_path"]; ok {
		value := expandString(v)

		out.AuditLogPath = &value
	}

	if v, ok := d["audit_policy_file"]; ok {
		out.AuditPolicyFile = expandString(v)
	}

	if v, ok := d["audit_webhook_batch_buffer_size"]; ok {
		value := expandInt32(v)

		out.AuditWebhookBatchBufferSize = &value
	}

	if v, ok := d["audit_webhook_batch_max_size"]; ok {
		value := expandInt32(v)

		out.AuditWebhookBatchMaxSize = &value
	}

	if v, ok := d["audit_webhook_batch_max_wait"]; ok {
		out.AuditWebhookBatchMaxWait = expandDuration(v)
	}

	if v, ok := d["audit_webhook_batch_throttle_burst"]; ok {
		value := expandInt32(v)

		out.AuditWebhookBatchThrottleBurst = &value
	}

	if v, ok := d["audit_webhook_batch_throttle_enable"]; ok {
		out.AuditWebhookBatchThrottleEnable = expandBool(v)
	}

	if v, ok := d["audit_webhook_batch_throttle_qps"]; ok {
		out.AuditWebhookBatchThrottleQps = expandFloat32(v)
	}

	if v, ok := d["audit_webhook_config_file"]; ok {
		out.AuditWebhookConfigFile = expandString(v)
	}

	if v, ok := d["audit_webhook_initial_backoff"]; ok {
		out.AuditWebhookInitialBackoff = expandDuration(v)
	}

	if v, ok := d["audit_webhook_mode"]; ok {
		out.AuditWebhookMode = expandString(v)
	}

	if v, ok := d["authentication_token_webhook_cache_ttl"]; ok {
		out.AuthenticationTokenWebhookCacheTTL = expandDuration(v)
	}

	if v, ok := d["authentication_token_webhook_config_file"]; ok {
		value := expandString(v)

		out.AuthenticationTokenWebhookConfigFile = &value
	}

	if v, ok := d["authorization_mode"]; ok {
		value := expandString(v)

		out.AuthorizationMode = &value
	}

	if v, ok := d["authorization_rbac_super_user"]; ok {
		value := expandString(v)

		out.AuthorizationRBACSuperUser = &value
	}

	if v, ok := d["authorization_webhook_cache_authorized_ttl"]; ok {
		out.AuthorizationWebhookCacheAuthorizedTTL = expandDuration(v)
	}

	if v, ok := d["authorization_webhook_cache_unauthorized_ttl"]; ok {
		out.AuthorizationWebhookCacheUnauthorizedTTL = expandDuration(v)
	}

	if v, ok := d["authorization_webhook_config_file"]; ok {
		value := expandString(v)

		out.AuthorizationWebhookConfigFile = &value
	}

	if v, ok := d["basic_auth_file"]; ok {
		out.BasicAuthFile = expandString(v)
	}

	if v, ok := d["bind_address"]; ok {
		out.BindAddress = expandString(v)
	}

	if v, ok := d["cpu_request"]; ok {
		out.CPURequest = expandString(v)
	}

	if v, ok := d["client_ca_file"]; ok {
		out.ClientCAFile = expandString(v)
	}

	if v, ok := d["cloud_provider"]; ok {
		out.CloudProvider = expandString(v)
	}

	if v, ok := d["disable_admission_plugins"]; ok {
		out.DisableAdmissionPlugins = expandStringSlice(v)
	}

	if v, ok := d["disable_basic_auth"]; ok {
		value := expandBool(v)

		out.DisableBasicAuth = (*value)
	}

	if v, ok := d["enable_admission_plugins"]; ok {
		out.EnableAdmissionPlugins = expandStringSlice(v)
	}

	if v, ok := d["enable_aggregator_routing"]; ok {
		out.EnableAggregatorRouting = expandBool(v)
	}

	if v, ok := d["enable_bootstrap_token_auth"]; ok {
		out.EnableBootstrapAuthToken = expandBool(v)
	}

	if v, ok := d["etcd_ca_file"]; ok {
		out.EtcdCAFile = expandString(v)
	}

	if v, ok := d["etcd_cert_file"]; ok {
		out.EtcdCertFile = expandString(v)
	}

	if v, ok := d["etcd_key_file"]; ok {
		out.EtcdKeyFile = expandString(v)
	}

	if v, ok := d["etcd_quorum_read"]; ok {
		out.EtcdQuorumRead = expandBool(v)
	}

	if v, ok := d["etcd_servers"]; ok {
		out.EtcdServers = expandStringSlice(v)
	}

	if v, ok := d["etcd_servers_overrides"]; ok {
		out.EtcdServersOverrides = expandStringSlice(v)
	}

	if v, ok := d["event_ttl"]; ok {
		out.EventTTL = expandDuration(v)
	}

	if v, ok := d["experimental_encryption_provider_config"]; ok {
		value := expandString(v)

		out.ExperimentalEncryptionProviderConfig = &value
	}

	if v, ok := d["feature_gates"]; ok {
		out.FeatureGates = expandStringMap(v)
	}

	if v, ok := d["http_2max_streams_per_connection"]; ok {
		value := expandInt32(v)

		out.HTTP2MaxStreamsPerConnection = &value
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["insecure_bind_address"]; ok {
		out.InsecureBindAddress = expandString(v)
	}

	if v, ok := d["insecure_port"]; ok {
		out.InsecurePort = expandInt32(v)
	}

	if v, ok := d["kubelet_client_certificate"]; ok {
		out.KubeletClientCertificate = expandString(v)
	}

	if v, ok := d["kubelet_client_key"]; ok {
		out.KubeletClientKey = expandString(v)
	}

	if v, ok := d["kubelet_preferred_address_types"]; ok {
		out.KubeletPreferredAddressTypes = expandStringSlice(v)
	}

	if v, ok := d["log_level"]; ok {
		out.LogLevel = expandInt32(v)
	}

	if v, ok := d["max_mutating_requests_inflight"]; ok {
		out.MaxMutatingRequestsInflight = expandInt32(v)
	}

	if v, ok := d["max_requests_inflight"]; ok {
		out.MaxRequestsInflight = expandInt32(v)
	}

	if v, ok := d["min_request_timeout"]; ok {
		value := expandInt32(v)

		out.MinRequestTimeout = &value
	}

	if v, ok := d["oidc_ca_file"]; ok {
		value := expandString(v)

		out.OIDCCAFile = &value
	}

	if v, ok := d["oidc_client_id"]; ok {
		value := expandString(v)

		out.OIDCClientID = &value
	}

	if v, ok := d["oidc_groups_claim"]; ok {
		value := expandString(v)

		out.OIDCGroupsClaim = &value
	}

	if v, ok := d["oidc_groups_prefix"]; ok {
		value := expandString(v)

		out.OIDCGroupsPrefix = &value
	}

	if v, ok := d["oidc_issuer_url"]; ok {
		value := expandString(v)

		out.OIDCIssuerURL = &value
	}

	if v, ok := d["oidc_required_claim"]; ok {
		out.OIDCRequiredClaim = expandStringSlice(v)
	}

	if v, ok := d["oidc_username_claim"]; ok {
		value := expandString(v)

		out.OIDCUsernameClaim = &value
	}

	if v, ok := d["oidc_username_prefix"]; ok {
		value := expandString(v)

		out.OIDCUsernamePrefix = &value
	}

	if v, ok := d["proxy_client_cert_file"]; ok {
		value := expandString(v)

		out.ProxyClientCertFile = &value
	}

	if v, ok := d["proxy_client_key_file"]; ok {
		value := expandString(v)

		out.ProxyClientKeyFile = &value
	}

	if v, ok := d["requestheader_allowed_names"]; ok {
		out.RequestheaderAllowedNames = expandStringSlice(v)
	}

	if v, ok := d["requestheader_client_ca_file"]; ok {
		out.RequestheaderClientCAFile = expandString(v)
	}

	if v, ok := d["requestheader_extra_header_prefixes"]; ok {
		out.RequestheaderExtraHeaderPrefixes = expandStringSlice(v)
	}

	if v, ok := d["requestheader_group_headers"]; ok {
		out.RequestheaderGroupHeaders = expandStringSlice(v)
	}

	if v, ok := d["requestheader_username_headers"]; ok {
		out.RequestheaderUsernameHeaders = expandStringSlice(v)
	}

	if v, ok := d["runtime_config"]; ok {
		out.RuntimeConfig = expandStringMap(v)
	}

	if v, ok := d["secure_port"]; ok {
		out.SecurePort = expandInt32(v)
	}

	if v, ok := d["service_account_issuer"]; ok {
		value := expandString(v)

		out.ServiceAccountIssuer = &value
	}

	if v, ok := d["service_account_key_file"]; ok {
		out.ServiceAccountKeyFile = expandStringSlice(v)
	}

	if v, ok := d["service_account_signing_key_file"]; ok {
		value := expandString(v)

		out.ServiceAccountSigningKeyFile = &value
	}

	if v, ok := d["service_cluster_ip_range"]; ok {
		out.ServiceClusterIPRange = expandString(v)
	}

	if v, ok := d["service_node_port_range"]; ok {
		out.ServiceNodePortRange = expandString(v)
	}

	if v, ok := d["storage_backend"]; ok {
		value := expandString(v)

		out.StorageBackend = &value
	}

	if v, ok := d["tls_cert_file"]; ok {
		out.TLSCertFile = expandString(v)
	}

	if v, ok := d["tls_cipher_suites"]; ok {
		out.TLSCipherSuites = expandStringSlice(v)
	}

	if v, ok := d["tls_min_version"]; ok {
		out.TLSMinVersion = expandString(v)
	}

	if v, ok := d["tls_private_key_file"]; ok {
		out.TLSPrivateKeyFile = expandString(v)
	}

	if v, ok := d["target_ram_mb"]; ok {
		out.TargetRamMb = expandInt32(v)
	}

	if v, ok := d["token_auth_file"]; ok {
		out.TokenAuthFile = expandString(v)
	}

	return out
}

func expandKubeControllerManagerConfig(in interface{}) *kops.KubeControllerManagerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeControllerManagerConfig{}

	if v, ok := d["allocate_node_cid_rss"]; ok {
		out.AllocateNodeCIDRs = expandBool(v)
	}

	if v, ok := d["attach_detach_reconcile_sync_period"]; ok {
		out.AttachDetachReconcileSyncPeriod = expandDuration(v)
	}

	if v, ok := d["cidr_allocator_type"]; ok {
		value := expandString(v)

		out.CIDRAllocatorType = &value
	}

	if v, ok := d["cloud_provider"]; ok {
		out.CloudProvider = expandString(v)
	}

	if v, ok := d["cluster_cidr"]; ok {
		out.ClusterCIDR = expandString(v)
	}

	if v, ok := d["cluster_name"]; ok {
		out.ClusterName = expandString(v)
	}

	if v, ok := d["configure_cloud_routes"]; ok {
		out.ConfigureCloudRoutes = expandBool(v)
	}

	if v, ok := d["controllers"]; ok {
		out.Controllers = expandStringSlice(v)
	}

	if v, ok := d["experimental_cluster_signing_duration"]; ok {
		out.ExperimentalClusterSigningDuration = expandDuration(v)
	}

	if v, ok := d["feature_gates"]; ok {
		out.FeatureGates = expandStringMap(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_downscale_delay"]; ok {
		out.HorizontalPodAutoscalerDownscaleDelay = expandDuration(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_downscale_stabilization"]; ok {
		out.HorizontalPodAutoscalerDownscaleStabilization = expandDuration(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_sync_period"]; ok {
		out.HorizontalPodAutoscalerSyncPeriod = expandDuration(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_tolerance"]; ok {
		out.HorizontalPodAutoscalerTolerance = expandFloat64(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_upscale_delay"]; ok {
		out.HorizontalPodAutoscalerUpscaleDelay = expandDuration(v)
	}

	if v, ok := d["horizontal_pod_autoscaler_use_rest_clients"]; ok {
		out.HorizontalPodAutoscalerUseRestClients = expandBool(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["kube_api_burst"]; ok {
		value := expandInt32(v)

		out.KubeAPIBurst = &value
	}

	if v, ok := d["kube_apiqps"]; ok {
		out.KubeAPIQPS = expandFloat32(v)
	}

	if v, ok := d["leader_election"]; ok {
		out.LeaderElection = expandLeaderElectionConfiguration(v)
	}

	if v, ok := d["log_level"]; ok {
		out.LogLevel = expandInt32(v)
	}

	if v, ok := d["master"]; ok {
		out.Master = expandString(v)
	}

	if v, ok := d["min_resync_period"]; ok {
		out.MinResyncPeriod = expandString(v)
	}

	if v, ok := d["node_cidr_mask_size"]; ok {
		value := expandInt32(v)

		out.NodeCIDRMaskSize = &value
	}

	if v, ok := d["node_monitor_grace_period"]; ok {
		out.NodeMonitorGracePeriod = expandDuration(v)
	}

	if v, ok := d["node_monitor_period"]; ok {
		out.NodeMonitorPeriod = expandDuration(v)
	}

	if v, ok := d["pod_eviction_timeout"]; ok {
		out.PodEvictionTimeout = expandDuration(v)
	}

	if v, ok := d["root_ca_file"]; ok {
		out.RootCAFile = expandString(v)
	}

	if v, ok := d["service_account_private_key_file"]; ok {
		out.ServiceAccountPrivateKeyFile = expandString(v)
	}

	if v, ok := d["tls_cipher_suites"]; ok {
		out.TLSCipherSuites = expandStringSlice(v)
	}

	if v, ok := d["tls_min_version"]; ok {
		out.TLSMinVersion = expandString(v)
	}

	if v, ok := d["terminated_pod_gc_threshold"]; ok {
		value := expandInt32(v)

		out.TerminatedPodGCThreshold = &value
	}

	if v, ok := d["use_service_account_credentials"]; ok {
		out.UseServiceAccountCredentials = expandBool(v)
	}

	return out
}

func expandKubeDNSConfig(in interface{}) *kops.KubeDNSConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeDNSConfig{}

	if v, ok := d["cpu_request"]; ok {
		out.CPURequest = expandQuantity(v)
	}

	if v, ok := d["cache_max_concurrent"]; ok {
		out.CacheMaxConcurrent = expandInt(v)
	}

	if v, ok := d["cache_max_size"]; ok {
		out.CacheMaxSize = expandInt(v)
	}

	if v, ok := d["domain"]; ok {
		out.Domain = expandString(v)
	}

	if v, ok := d["external_core_file"]; ok {
		out.ExternalCoreFile = expandString(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["memory_limit"]; ok {
		out.MemoryLimit = expandQuantity(v)
	}

	if v, ok := d["memory_request"]; ok {
		out.MemoryRequest = expandQuantity(v)
	}

	if v, ok := d["provider"]; ok {
		out.Provider = expandString(v)
	}

	if v, ok := d["replicas"]; ok {
		out.Replicas = expandInt(v)
	}

	if v, ok := d["server_ip"]; ok {
		out.ServerIP = expandString(v)
	}

	if v, ok := d["stub_domains"]; ok {
		out.StubDomains = expandStringSliceMap(v)
	}

	if v, ok := d["upstream_nameservers"]; ok {
		out.UpstreamNameservers = expandStringSlice(v)
	}

	return out
}

func expandKubeProxyConfig(in interface{}) *kops.KubeProxyConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeProxyConfig{}

	if v, ok := d["bind_address"]; ok {
		out.BindAddress = expandString(v)
	}

	if v, ok := d["cpu_limit"]; ok {
		out.CPULimit = expandString(v)
	}

	if v, ok := d["cpu_request"]; ok {
		out.CPURequest = expandString(v)
	}

	if v, ok := d["cluster_cidr"]; ok {
		out.ClusterCIDR = expandString(v)
	}

	if v, ok := d["conntrack_max_per_core"]; ok {
		value := expandInt32(v)

		out.ConntrackMaxPerCore = &value
	}

	if v, ok := d["conntrack_min"]; ok {
		value := expandInt32(v)

		out.ConntrackMin = &value
	}

	if v, ok := d["enabled"]; ok {
		out.Enabled = expandBool(v)
	}

	if v, ok := d["feature_gates"]; ok {
		out.FeatureGates = expandStringMap(v)
	}

	if v, ok := d["hostname_override"]; ok {
		out.HostnameOverride = expandString(v)
	}

	if v, ok := d["ipvs_exclude_cidrs"]; ok {
		out.IPVSExcludeCIDRS = expandStringSlice(v)
	}

	if v, ok := d["ipvs_min_sync_period"]; ok {
		out.IPVSMinSyncPeriod = expandDuration(v)
	}

	if v, ok := d["ipvs_scheduler"]; ok {
		value := expandString(v)

		out.IPVSScheduler = &value
	}

	if v, ok := d["ipvs_sync_period"]; ok {
		out.IPVSSyncPeriod = expandDuration(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["log_level"]; ok {
		out.LogLevel = expandInt32(v)
	}

	if v, ok := d["master"]; ok {
		out.Master = expandString(v)
	}

	if v, ok := d["memory_limit"]; ok {
		out.MemoryLimit = expandString(v)
	}

	if v, ok := d["memory_request"]; ok {
		out.MemoryRequest = expandString(v)
	}

	if v, ok := d["metrics_bind_address"]; ok {
		value := expandString(v)

		out.MetricsBindAddress = &value
	}

	if v, ok := d["proxy_mode"]; ok {
		out.ProxyMode = expandString(v)
	}

	return out
}

func expandKubeSchedulerConfig(in interface{}) *kops.KubeSchedulerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.KubeSchedulerConfig{}

	if v, ok := d["feature_gates"]; ok {
		out.FeatureGates = expandStringMap(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["leader_election"]; ok {
		out.LeaderElection = expandLeaderElectionConfiguration(v)
	}

	if v, ok := d["log_level"]; ok {
		out.LogLevel = expandInt32(v)
	}

	if v, ok := d["master"]; ok {
		out.Master = expandString(v)
	}

	if v, ok := d["max_persistent_volumes"]; ok {
		value := expandInt32(v)

		out.MaxPersistentVolumes = &value
	}

	if v, ok := d["use_policy_config_map"]; ok {
		out.UsePolicyConfigMap = expandBool(v)
	}

	return out
}

func expandKubenetNetworkingSpec(in interface{}) *kops.KubenetNetworkingSpec {
	out := in.(*kops.KubenetNetworkingSpec)

	return out
}

func expandKuberouterNetworkingSpec(in interface{}) *kops.KuberouterNetworkingSpec {
	out := in.(*kops.KuberouterNetworkingSpec)

	return out
}

func expandLeaderElectionConfiguration(in interface{}) *kops.LeaderElectionConfiguration {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.LeaderElectionConfiguration{}

	if v, ok := d["leader_elect"]; ok {
		out.LeaderElect = expandBool(v)
	}

	return out
}

func expandListMeta(in interface{}) v1.ListMeta {
	d := in.([]interface{})[0].(map[string]interface{})
	out := v1.ListMeta{}

	if v, ok := d["continue"]; ok {
		out.Continue = expandString(v)
	}

	if v, ok := d["remaining_item_count"]; ok {
		value := expandInt64(v)

		out.RemainingItemCount = &value
	}

	if v, ok := d["resource_version"]; ok {
		out.ResourceVersion = expandString(v)
	}

	if v, ok := d["self_link"]; ok {
		out.SelfLink = expandString(v)
	}

	return out
}

func expandLoadBalancerAccessSpec(in interface{}) *kops.LoadBalancerAccessSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.LoadBalancerAccessSpec{}

	if v, ok := d["additional_security_groups"]; ok {
		out.AdditionalSecurityGroups = expandStringSlice(v)
	}

	if v, ok := d["cross_zone_load_balancing"]; ok {
		out.CrossZoneLoadBalancing = expandBool(v)
	}

	if v, ok := d["idle_timeout_seconds"]; ok {
		value := expandInt64(v)

		out.IdleTimeoutSeconds = &value
	}

	if v, ok := d["ssl_certificate"]; ok {
		out.SSLCertificate = expandString(v)
	}

	if v, ok := d["security_group_override"]; ok {
		value := expandString(v)

		out.SecurityGroupOverride = &value
	}

	if v, ok := d["type"]; ok {
		out.Type = expandLoadBalancerType(v)
	}

	if v, ok := d["use_for_internal_api"]; ok {
		value := expandBool(v)

		out.UseForInternalApi = (*value)
	}

	return out
}

func expandLoadBalancerType(in interface{}) kops.LoadBalancerType {
	out := in.(kops.LoadBalancerType)

	return out
}

func expandLyftVPCNetworkingSpec(in interface{}) *kops.LyftVPCNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.LyftVPCNetworkingSpec{}

	if v, ok := d["subnet_tags"]; ok {
		out.SubnetTags = expandStringMap(v)
	}

	return out
}

func expandManagedFieldsOperationType(in interface{}) v1.ManagedFieldsOperationType {
	out := in.(v1.ManagedFieldsOperationType)

	return out
}

func expandNetworkingSpec(in interface{}) *kops.NetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.NetworkingSpec{}

	if v, ok := d["amazonvpc"]; ok {
		out.AmazonVPC = expandAmazonVPCNetworkingSpec(v)
	}

	if v, ok := d["cni"]; ok {
		out.CNI = expandCNINetworkingSpec(v)
	}

	if v, ok := d["calico"]; ok {
		out.Calico = expandCalicoNetworkingSpec(v)
	}

	if v, ok := d["canal"]; ok {
		out.Canal = expandCanalNetworkingSpec(v)
	}

	if v, ok := d["cilium"]; ok {
		out.Cilium = expandCiliumNetworkingSpec(v)
	}

	if v, ok := d["classic"]; ok {
		out.Classic = expandClassicNetworkingSpec(v)
	}

	if v, ok := d["external"]; ok {
		out.External = expandExternalNetworkingSpec(v)
	}

	if v, ok := d["flannel"]; ok {
		out.Flannel = expandFlannelNetworkingSpec(v)
	}

	if v, ok := d["gce"]; ok {
		out.GCE = expandGCENetworkingSpec(v)
	}

	if v, ok := d["kopeio"]; ok {
		out.Kopeio = expandKopeioNetworkingSpec(v)
	}

	if v, ok := d["kubenet"]; ok {
		out.Kubenet = expandKubenetNetworkingSpec(v)
	}

	if v, ok := d["kuberouter"]; ok {
		out.Kuberouter = expandKuberouterNetworkingSpec(v)
	}

	if v, ok := d["lyftvpc"]; ok {
		out.LyftVPC = expandLyftVPCNetworkingSpec(v)
	}

	if v, ok := d["romana"]; ok {
		out.Romana = expandRomanaNetworkingSpec(v)
	}

	if v, ok := d["weave"]; ok {
		out.Weave = expandWeaveNetworkingSpec(v)
	}

	return out
}

func expandNodeAuthorizationSpec(in interface{}) *kops.NodeAuthorizationSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.NodeAuthorizationSpec{}

	if v, ok := d["node_authorizer"]; ok {
		out.NodeAuthorizer = expandNodeAuthorizerSpec(v)
	}

	return out
}

func expandNodeAuthorizerSpec(in interface{}) *kops.NodeAuthorizerSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.NodeAuthorizerSpec{}

	if v, ok := d["authorizer"]; ok {
		out.Authorizer = expandString(v)
	}

	if v, ok := d["features"]; ok {
		value := expandStringSlice(v)

		out.Features = &value
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["interval"]; ok {
		out.Interval = expandDuration(v)
	}

	if v, ok := d["node_url"]; ok {
		out.NodeURL = expandString(v)
	}

	if v, ok := d["port"]; ok {
		out.Port = expandInt(v)
	}

	if v, ok := d["timeout"]; ok {
		out.Timeout = expandDuration(v)
	}

	if v, ok := d["token_ttl"]; ok {
		out.TokenTTL = expandDuration(v)
	}

	return out
}

func expandOpenstackBlockStorageConfig(in interface{}) *kops.OpenstackBlockStorageConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.OpenstackBlockStorageConfig{}

	if v, ok := d["ignore_volume_az"]; ok {
		out.IgnoreAZ = expandBool(v)
	}

	if v, ok := d["override_volume_az"]; ok {
		value := expandString(v)

		out.OverrideAZ = &value
	}

	if v, ok := d["bs_version"]; ok {
		value := expandString(v)

		out.Version = &value
	}

	return out
}

func expandOpenstackConfiguration(in interface{}) *kops.OpenstackConfiguration {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.OpenstackConfiguration{}

	if v, ok := d["block_storage"]; ok {
		out.BlockStorage = expandOpenstackBlockStorageConfig(v)
	}

	if v, ok := d["insecure_skip_verify"]; ok {
		out.InsecureSkipVerify = expandBool(v)
	}

	if v, ok := d["loadbalancer"]; ok {
		out.Loadbalancer = expandOpenstackLoadbalancerConfig(v)
	}

	if v, ok := d["monitor"]; ok {
		out.Monitor = expandOpenstackMonitor(v)
	}

	if v, ok := d["router"]; ok {
		out.Router = expandOpenstackRouter(v)
	}

	return out
}

func expandOpenstackLoadbalancerConfig(in interface{}) *kops.OpenstackLoadbalancerConfig {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.OpenstackLoadbalancerConfig{}

	if v, ok := d["floating_network"]; ok {
		value := expandString(v)

		out.FloatingNetwork = &value
	}

	if v, ok := d["floating_network_id"]; ok {
		value := expandString(v)

		out.FloatingNetworkID = &value
	}

	if v, ok := d["floating_subnet"]; ok {
		value := expandString(v)

		out.FloatingSubnet = &value
	}

	if v, ok := d["manage_security_groups"]; ok {
		out.ManageSecGroups = expandBool(v)
	}

	if v, ok := d["method"]; ok {
		value := expandString(v)

		out.Method = &value
	}

	if v, ok := d["provider"]; ok {
		value := expandString(v)

		out.Provider = &value
	}

	if v, ok := d["subnet_id"]; ok {
		value := expandString(v)

		out.SubnetID = &value
	}

	if v, ok := d["use_octavia"]; ok {
		out.UseOctavia = expandBool(v)
	}

	return out
}

func expandOpenstackMonitor(in interface{}) *kops.OpenstackMonitor {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.OpenstackMonitor{}

	if v, ok := d["delay"]; ok {
		value := expandString(v)

		out.Delay = &value
	}

	if v, ok := d["max_retries"]; ok {
		value := expandInt(v)

		out.MaxRetries = &value
	}

	if v, ok := d["timeout"]; ok {
		value := expandString(v)

		out.Timeout = &value
	}

	return out
}

func expandOpenstackRouter(in interface{}) *kops.OpenstackRouter {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.OpenstackRouter{}

	if v, ok := d["dns_servers"]; ok {
		value := expandString(v)

		out.DNSServers = &value
	}

	if v, ok := d["external_network"]; ok {
		value := expandString(v)

		out.ExternalNetwork = &value
	}

	if v, ok := d["external_subnet"]; ok {
		value := expandString(v)

		out.ExternalSubnet = &value
	}

	return out
}

func expandRBACAuthorizationSpec(in interface{}) *kops.RBACAuthorizationSpec {
	out := in.(*kops.RBACAuthorizationSpec)

	return out
}

func expandRomanaNetworkingSpec(in interface{}) *kops.RomanaNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.RomanaNetworkingSpec{}

	if v, ok := d["daemon_service_ip"]; ok {
		out.DaemonServiceIP = expandString(v)
	}

	if v, ok := d["etcd_service_ip"]; ok {
		out.EtcdServiceIP = expandString(v)
	}

	return out
}

func expandStatus(in interface{}) *v1.Status {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &v1.Status{}

	if v, ok := d["code"]; ok {
		out.Code = expandInt32(v)
	}

	if v, ok := d["details"]; ok {
		out.Details = expandStatusDetails(v)
	}

	if v, ok := d["metadata"]; ok {
		out.ListMeta = expandListMeta(v)
	}

	if v, ok := d["message"]; ok {
		out.Message = expandString(v)
	}

	if v, ok := d["reason"]; ok {
		out.Reason = expandStatusReason(v)
	}

	if v, ok := d["status"]; ok {
		out.Status = expandString(v)
	}

	{
		out.TypeMeta = expandTypeMeta(in)
	}

	return out
}

func expandStatusCauseSlice(in interface{}) []v1.StatusCause {
	d := in.([]interface{})
	out := make([]v1.StatusCause , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = v1.StatusCause{}

		if v, ok := d[i].(map[string]interface{})["field"]; ok {
			out[i].Field = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["message"]; ok {
			out[i].Message = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["reason"]; ok {
			out[i].Type = expandCauseType(v)
		}
	}

	return out
}

func expandStatusDetails(in interface{}) *v1.StatusDetails {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &v1.StatusDetails{}

	if v, ok := d["causes"]; ok {
		out.Causes = expandStatusCauseSlice(v)
	}

	if v, ok := d["group"]; ok {
		out.Group = expandString(v)
	}

	if v, ok := d["kind"]; ok {
		out.Kind = expandString(v)
	}

	if v, ok := d["name"]; ok {
		out.Name = expandString(v)
	}

	if v, ok := d["retry_after_seconds"]; ok {
		out.RetryAfterSeconds = expandInt32(v)
	}

	if v, ok := d["uid"]; ok {
		out.UID = expandUID(v)
	}

	return out
}

func expandStatusReason(in interface{}) v1.StatusReason {
	out := in.(v1.StatusReason)

	return out
}

func expandStringSliceMap(in interface{}) map[string][]string {
	out := in.(map[string][]string)

	return out
}

func expandSubnetType(in interface{}) kops.SubnetType {
	out := in.(kops.SubnetType)

	return out
}

func expandTargetSpec(in interface{}) *kops.TargetSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.TargetSpec{}

	if v, ok := d["terraform"]; ok {
		out.Terraform = expandTerraformSpec(v)
	}

	return out
}

func expandTerraformSpec(in interface{}) *kops.TerraformSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.TerraformSpec{}

	if v, ok := d["provider_extra_config"]; ok {
		value := expandStringMap(v)

		out.ProviderExtraConfig = &value
	}

	return out
}

func expandTopologySpec(in interface{}) *kops.TopologySpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.TopologySpec{}

	if v, ok := d["bastion"]; ok {
		out.Bastion = expandBastionSpec(v)
	}

	if v, ok := d["dns"]; ok {
		out.DNS = expandDNSSpec(v)
	}

	if v, ok := d["masters"]; ok {
		out.Masters = expandString(v)
	}

	if v, ok := d["nodes"]; ok {
		out.Nodes = expandString(v)
	}

	return out
}

func expandUint32(in interface{}) uint32 {
	out := in.(uint32)

	return out
}

func expandWeaveNetworkingSpec(in interface{}) *kops.WeaveNetworkingSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.WeaveNetworkingSpec{}

	if v, ok := d["conn_limit"]; ok {
		value := expandInt32(v)

		out.ConnLimit = &value
	}

	if v, ok := d["mtu"]; ok {
		value := expandInt32(v)

		out.MTU = &value
	}

	if v, ok := d["net_extra_args"]; ok {
		out.NetExtraArgs = expandString(v)
	}

	if v, ok := d["no_masq_local"]; ok {
		value := expandInt32(v)

		out.NoMasqLocal = &value
	}

	return out
}
