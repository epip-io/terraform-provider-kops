// Code generated by engine.go; DO NOT EDIT.

package provider

import (
	"k8s.io/kops/pkg/apis/kops"
)

func expandIAMProfileSpec(in interface{}) *kops.IAMProfileSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.IAMProfileSpec{}

	if v, ok := d["profile"]; ok {
		value := expandString(v)

		out.Profile = &value
	}

	return out
}

func expandInstanceGroupRole(in interface{}) kops.InstanceGroupRole {
	out := in.(kops.InstanceGroupRole)

	return out
}

func expandInstanceGroupSpec(in interface{}) kops.InstanceGroupSpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := kops.InstanceGroupSpec{}

	if v, ok := d["additional_security_groups"]; ok {
		out.AdditionalSecurityGroups = expandStringSlice(v)
	}

	if v, ok := d["additional_user_data"]; ok {
		out.AdditionalUserData = expandUserDataSlice(v)
	}

	if v, ok := d["associate_public_ip"]; ok {
		out.AssociatePublicIP = expandBool(v)
	}

	if v, ok := d["cloud_labels"]; ok {
		out.CloudLabels = expandStringMap(v)
	}

	if v, ok := d["detailed_instance_monitoring"]; ok {
		out.DetailedInstanceMonitoring = expandBool(v)
	}

	if v, ok := d["external_load_balancers"]; ok {
		out.ExternalLoadBalancers = expandLoadBalancerSlice(v)
	}

	if v, ok := d["file_assets"]; ok {
		out.FileAssets = expandFileAssetSpecSlice(v)
	}

	if v, ok := d["hooks"]; ok {
		out.Hooks = expandHookSpecSlice(v)
	}

	if v, ok := d["iam"]; ok {
		out.IAM = expandIAMProfileSpec(v)
	}

	if v, ok := d["image"]; ok {
		out.Image = expandString(v)
	}

	if v, ok := d["instance_protection"]; ok {
		out.InstanceProtection = expandBool(v)
	}

	if v, ok := d["kubelet"]; ok {
		out.Kubelet = expandKubeletConfigSpec(v)
	}

	if v, ok := d["machine_type"]; ok {
		out.MachineType = expandString(v)
	}

	if v, ok := d["max_price"]; ok {
		value := expandString(v)

		out.MaxPrice = &value
	}

	if v, ok := d["max_size"]; ok {
		value := expandInt32(v)

		out.MaxSize = &value
	}

	if v, ok := d["min_size"]; ok {
		value := expandInt32(v)

		out.MinSize = &value
	}

	if v, ok := d["mixed_instances_policy"]; ok {
		out.MixedInstancesPolicy = expandMixedInstancesPolicySpec(v)
	}

	if v, ok := d["node_labels"]; ok {
		out.NodeLabels = expandStringMap(v)
	}

	if v, ok := d["role"]; ok {
		out.Role = expandInstanceGroupRole(v)
	}

	if v, ok := d["root_volume_iops"]; ok {
		value := expandInt32(v)

		out.RootVolumeIops = &value
	}

	if v, ok := d["root_volume_optimization"]; ok {
		out.RootVolumeOptimization = expandBool(v)
	}

	if v, ok := d["root_volume_size"]; ok {
		value := expandInt32(v)

		out.RootVolumeSize = &value
	}

	if v, ok := d["root_volume_type"]; ok {
		value := expandString(v)

		out.RootVolumeType = &value
	}

	if v, ok := d["security_group_override"]; ok {
		value := expandString(v)

		out.SecurityGroupOverride = &value
	}

	if v, ok := d["subnets"]; ok {
		out.Subnets = expandStringSlice(v)
	}

	if v, ok := d["suspend_processes"]; ok {
		out.SuspendProcesses = expandStringSlice(v)
	}

	if v, ok := d["taints"]; ok {
		out.Taints = expandStringSlice(v)
	}

	if v, ok := d["tenancy"]; ok {
		out.Tenancy = expandString(v)
	}

	if v, ok := d["volume_mounts"]; ok {
		out.VolumeMounts = expandVolumeMountSpecSlice(v)
	}

	if v, ok := d["volumes"]; ok {
		out.Volumes = expandVolumeSpecSlice(v)
	}

	if v, ok := d["zones"]; ok {
		out.Zones = expandStringSlice(v)
	}

	return out
}

func expandLoadBalancerSlice(in interface{}) []kops.LoadBalancer {
	d := in.([]interface{})
	out := make([]kops.LoadBalancer , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.LoadBalancer{}

		if v, ok := d[i].(map[string]interface{})["load_balancer_name"]; ok {
			value := expandString(v)

			out[i].LoadBalancerName = &value
		}

		if v, ok := d[i].(map[string]interface{})["target_group_arn"]; ok {
			value := expandString(v)

			out[i].TargetGroupARN = &value
		}
	}

	return out
}

func expandMixedInstancesPolicySpec(in interface{}) *kops.MixedInstancesPolicySpec {
	d := in.([]interface{})[0].(map[string]interface{})
	out := &kops.MixedInstancesPolicySpec{}

	if v, ok := d["instances"]; ok {
		out.Instances = expandStringSlice(v)
	}

	if v, ok := d["on_demand_above_base"]; ok {
		value := expandInt64(v)

		out.OnDemandAboveBase = &value
	}

	if v, ok := d["on_demand_allocation_strategy"]; ok {
		value := expandString(v)

		out.OnDemandAllocationStrategy = &value
	}

	if v, ok := d["on_demand_base"]; ok {
		value := expandInt64(v)

		out.OnDemandBase = &value
	}

	if v, ok := d["spot_allocation_strategy"]; ok {
		value := expandString(v)

		out.SpotAllocationStrategy = &value
	}

	if v, ok := d["spot_instance_pools"]; ok {
		value := expandInt64(v)

		out.SpotInstancePools = &value
	}

	return out
}

func expandUserDataSlice(in interface{}) []kops.UserData {
	d := in.([]interface{})
	out := make([]kops.UserData , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = kops.UserData{}

		if v, ok := d[i].(map[string]interface{})["content"]; ok {
			out[i].Content = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["name"]; ok {
			out[i].Name = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["type"]; ok {
			out[i].Type = expandString(v)
		}
	}

	return out
}

func expandVolumeMountSpecSlice(in interface{}) []*kops.VolumeMountSpec {
	d := in.([]interface{})
	out := make([]*kops.VolumeMountSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = &kops.VolumeMountSpec{}

		if v, ok := d[i].(map[string]interface{})["device"]; ok {
			out[i].Device = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["filesystem"]; ok {
			out[i].Filesystem = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["format_options"]; ok {
			out[i].FormatOptions = expandStringSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["mount_options"]; ok {
			out[i].MountOptions = expandStringSlice(v)
		}

		if v, ok := d[i].(map[string]interface{})["path"]; ok {
			out[i].Path = expandString(v)
		}
	}

	return out
}

func expandVolumeSpecSlice(in interface{}) []*kops.VolumeSpec {
	d := in.([]interface{})
	out := make([]*kops.VolumeSpec , len(d))

	for i := 0; i < len(d); i++ {
		out[i] = &kops.VolumeSpec{}

		if v, ok := d[i].(map[string]interface{})["device"]; ok {
			out[i].Device = expandString(v)
		}

		if v, ok := d[i].(map[string]interface{})["encrypted"]; ok {
			out[i].Encrypted = expandBool(v)
		}

		if v, ok := d[i].(map[string]interface{})["iops"]; ok {
			value := expandInt64(v)

			out[i].Iops = &value
		}

		if v, ok := d[i].(map[string]interface{})["size"]; ok {
			out[i].Size = expandInt64(v)
		}

		if v, ok := d[i].(map[string]interface{})["type"]; ok {
			out[i].Type = expandString(v)
		}
	}

	return out
}
