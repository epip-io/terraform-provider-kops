// Code generated by engine.go; DO NOT EDIT.

package provider
import (
	"k8s.io/kops/pkg/apis/kops"

	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
)


func flattenAccessSpec(in *kops.AccessSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.DNS != nil {
			out[i]["dns"] = flattenDNSAccessSpec(in.DNS)
		}

		if 	in.LoadBalancer != nil {
			out[i]["load_balancer"] = flattenLoadBalancerAccessSpec(in.LoadBalancer)
		}
	}

	return out
}

func flattenAddonSpecSlice(in []kops.AddonSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Manifest != "" {
			out[i]["manifest"] = flattenString(in[i].Manifest)
		}
	}

	return out
}

func flattenAlwaysAllowAuthorizationSpec(in *kops.AlwaysAllowAuthorizationSpec) interface{} {
	out := *in

	return out
}

func flattenAmazonVPCNetworkingSpec(in *kops.AmazonVPCNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.ImageName != "" {
			out[i]["image_name"] = flattenString(in.ImageName)
		}
	}

	return out
}

func flattenAssets(in *kops.Assets) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.ContainerProxy != "" {
			out[i]["container_proxy"] = flattenString(*in.ContainerProxy)
		}

		if 	*in.ContainerRegistry != "" {
			out[i]["container_registry"] = flattenString(*in.ContainerRegistry)
		}

		if 	*in.FileRepository != "" {
			out[i]["file_repository"] = flattenString(*in.FileRepository)
		}
	}

	return out
}

func flattenAuthenticationSpec(in *kops.AuthenticationSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Aws != nil {
			out[i]["aws"] = flattenAwsAuthenticationSpec(in.Aws)
		}

		if 	in.Kopeio != nil {
			out[i]["kopeio"] = flattenKopeioAuthenticationSpec(in.Kopeio)
		}
	}

	return out
}

func flattenAuthorizationSpec(in *kops.AuthorizationSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AlwaysAllow != nil {
			out[i]["always_allow"] = flattenAlwaysAllowAuthorizationSpec(in.AlwaysAllow)
		}

		if 	in.RBAC != nil {
			out[i]["rbac"] = flattenRBACAuthorizationSpec(in.RBAC)
		}
	}

	return out
}

func flattenAwsAuthenticationSpec(in *kops.AwsAuthenticationSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.CPULimit != nil {
			out[i]["cpu_limit"] = flattenQuantity(in.CPULimit)
		}

		if 	in.CPURequest != nil {
			out[i]["cpu_request"] = flattenQuantity(in.CPURequest)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.MemoryLimit != nil {
			out[i]["memory_limit"] = flattenQuantity(in.MemoryLimit)
		}

		if 	in.MemoryRequest != nil {
			out[i]["memory_request"] = flattenQuantity(in.MemoryRequest)
		}
	}

	return out
}

func flattenBastionSpec(in *kops.BastionSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.BastionPublicName != "" {
			out[i]["bastion_public_name"] = flattenString(in.BastionPublicName)
		}

		if 	*in.IdleTimeoutSeconds != 0 {
			out[i]["idle_timeout_seconds"] = flattenInt64(*in.IdleTimeoutSeconds)
		}
	}

	return out
}

func flattenCNINetworkingSpec(in *kops.CNINetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.UsesSecondaryIP {
			out[i]["uses_secondary_ip"] = flattenBool(&in.UsesSecondaryIP)
		}
	}

	return out
}

func flattenCalicoNetworkingSpec(in *kops.CalicoNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.CrossSubnet {
			out[i]["cross_subnet"] = flattenBool(&in.CrossSubnet)
		}

		if 	in.IPIPMode != "" {
			out[i]["ipip_mode"] = flattenString(in.IPIPMode)
		}

		if 	in.LogSeverityScreen != "" {
			out[i]["log_severity_screen"] = flattenString(in.LogSeverityScreen)
		}

		if 	*in.MTU != 0 {
			out[i]["mtu"] = flattenInt32(*in.MTU)
		}

		if 	in.MajorVersion != "" {
			out[i]["major_version"] = flattenString(in.MajorVersion)
		}

		if 	in.PrometheusGoMetricsEnabled {
			out[i]["prometheus_go_metrics_enabled"] = flattenBool(&in.PrometheusGoMetricsEnabled)
		}

		if 	in.PrometheusMetricsEnabled {
			out[i]["prometheus_metrics_enabled"] = flattenBool(&in.PrometheusMetricsEnabled)
		}

		if 	in.PrometheusMetricsPort != 0 {
			out[i]["prometheus_metrics_port"] = flattenInt32(in.PrometheusMetricsPort)
		}

		if 	in.PrometheusProcessMetricsEnabled {
			out[i]["prometheus_process_metrics_enabled"] = flattenBool(&in.PrometheusProcessMetricsEnabled)
		}

		if 	in.TyphaPrometheusMetricsEnabled {
			out[i]["typha_prometheus_metrics_enabled"] = flattenBool(&in.TyphaPrometheusMetricsEnabled)
		}

		if 	in.TyphaPrometheusMetricsPort != 0 {
			out[i]["typha_prometheus_metrics_port"] = flattenInt32(in.TyphaPrometheusMetricsPort)
		}

		if 	in.TyphaReplicas != 0 {
			out[i]["typha_replicas"] = flattenInt32(in.TyphaReplicas)
		}
	}

	return out
}

func flattenCanalNetworkingSpec(in *kops.CanalNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.ChainInsertMode != "" {
			out[i]["chain_insert_mode"] = flattenString(in.ChainInsertMode)
		}

		if 	in.DefaultEndpointToHostAction != "" {
			out[i]["default_endpoint_to_host_action"] = flattenString(in.DefaultEndpointToHostAction)
		}

		if 	in.DisableFlannelForwardRules {
			out[i]["disable_flannel_forward_rules"] = flattenBool(&in.DisableFlannelForwardRules)
		}

		if 	in.LogSeveritySys != "" {
			out[i]["log_severity_sys"] = flattenString(in.LogSeveritySys)
		}

		if 	*in.MTU != 0 {
			out[i]["mtu"] = flattenInt32(*in.MTU)
		}

		if 	in.PrometheusGoMetricsEnabled {
			out[i]["prometheus_go_metrics_enabled"] = flattenBool(&in.PrometheusGoMetricsEnabled)
		}

		if 	in.PrometheusMetricsEnabled {
			out[i]["prometheus_metrics_enabled"] = flattenBool(&in.PrometheusMetricsEnabled)
		}

		if 	in.PrometheusMetricsPort != 0 {
			out[i]["prometheus_metrics_port"] = flattenInt32(in.PrometheusMetricsPort)
		}

		if 	in.PrometheusProcessMetricsEnabled {
			out[i]["prometheus_process_metrics_enabled"] = flattenBool(&in.PrometheusProcessMetricsEnabled)
		}
	}

	return out
}

func flattenCauseType(in v1.CauseType) interface{} {
	out := in

	return out
}

func flattenCiliumNetworkingSpec(in *kops.CiliumNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AccessLog != "" {
			out[i]["access_log"] = flattenString(in.AccessLog)
		}

		if 	in.AgentLabels != nil {
			out[i]["agent_labels"] = flattenStringSlice(in.AgentLabels)
		}

		if 	in.AllowLocalhost != "" {
			out[i]["allow_localhost"] = flattenString(in.AllowLocalhost)
		}

		out[i]["auto_direct_node_routes"] = flattenBool(&in.AutoDirectNodeRoutes)

		if 	in.AutoIpv6NodeRoutes {
			out[i]["auto_ipv_6node_routes"] = flattenBool(&in.AutoIpv6NodeRoutes)
		}

		out[i]["bpf_ct_global_any_max"] = flattenInt(in.BPFCTGlobalAnyMax)

		out[i]["bpf_ct_global_tcp_max"] = flattenInt(in.BPFCTGlobalTCPMax)

		if 	in.BPFRoot != "" {
			out[i]["bpf_root"] = flattenString(in.BPFRoot)
		}

		out[i]["cluster_name"] = flattenString(in.ClusterName)

		out[i]["cni_bin_path"] = flattenString(in.CniBinPath)

		if 	in.ContainerRuntime != nil {
			out[i]["container_runtime"] = flattenStringSlice(in.ContainerRuntime)
		}

		if 	in.ContainerRuntimeEndpoint != nil {
			out[i]["container_runtime_endpoint"] = flattenStringMap(in.ContainerRuntimeEndpoint)
		}

		if 	in.ContainerRuntimeLabels != "" {
			out[i]["container_runtime_labels"] = flattenString(in.ContainerRuntimeLabels)
		}

		if 	in.Debug {
			out[i]["debug"] = flattenBool(&in.Debug)
		}

		if 	in.DebugVerbose != nil {
			out[i]["debug_verbose"] = flattenStringSlice(in.DebugVerbose)
		}

		if 	in.Device != "" {
			out[i]["device"] = flattenString(in.Device)
		}

		if 	in.DisableConntrack {
			out[i]["disable_conntrack"] = flattenBool(&in.DisableConntrack)
		}

		if 	in.DisableIpv4 {
			out[i]["disable_ipv_4"] = flattenBool(&in.DisableIpv4)
		}

		if 	in.DisableK8sServices {
			out[i]["disable_k8s_services"] = flattenBool(&in.DisableK8sServices)
		}

		if 	in.DisableMasquerade {
			out[i]["disable_masquerade"] = flattenBool(&in.DisableMasquerade)
		}

		out[i]["enableipv_4"] = flattenBool(&in.EnableIpv4)

		out[i]["enableipv_6"] = flattenBool(&in.EnableIpv6)

		out[i]["enable_node_port"] = flattenBool(&in.EnableNodePort)

		if 	in.EnablePolicy != "" {
			out[i]["enable_policy"] = flattenString(in.EnablePolicy)
		}

		if 	in.EnableTracing {
			out[i]["enable_tracing"] = flattenBool(&in.EnableTracing)
		}

		if 	in.EnvoyLog != "" {
			out[i]["envoy_log"] = flattenString(in.EnvoyLog)
		}

		out[i]["ip_tables_rules_noinstall"] = flattenBool(&in.IPTablesRulesNoinstall)

		if 	in.Ipv4ClusterCIDRMaskSize != 0 {
			out[i]["ipv_4cluster_cidr_mask_size"] = flattenInt(in.Ipv4ClusterCIDRMaskSize)
		}

		if 	in.Ipv4Node != "" {
			out[i]["ipv_4node"] = flattenString(in.Ipv4Node)
		}

		if 	in.Ipv4Range != "" {
			out[i]["ipv_4range"] = flattenString(in.Ipv4Range)
		}

		if 	in.Ipv4ServiceRange != "" {
			out[i]["ipv_4service_range"] = flattenString(in.Ipv4ServiceRange)
		}

		if 	in.Ipv6ClusterAllocCidr != "" {
			out[i]["ipv_6cluster_alloc_cidr"] = flattenString(in.Ipv6ClusterAllocCidr)
		}

		if 	in.Ipv6Node != "" {
			out[i]["ipv_6node"] = flattenString(in.Ipv6Node)
		}

		if 	in.Ipv6Range != "" {
			out[i]["ipv_6range"] = flattenString(in.Ipv6Range)
		}

		if 	in.Ipv6ServiceRange != "" {
			out[i]["ipv_6service_range"] = flattenString(in.Ipv6ServiceRange)
		}

		if 	in.K8sAPIServer != "" {
			out[i]["k_8s_api_server"] = flattenString(in.K8sAPIServer)
		}

		if 	in.K8sKubeconfigPath != "" {
			out[i]["k_8s_kubeconfig_path"] = flattenString(in.K8sKubeconfigPath)
		}

		if 	in.KeepBPFTemplates {
			out[i]["keep_bpf_templates"] = flattenBool(&in.KeepBPFTemplates)
		}

		if 	in.KeepConfig {
			out[i]["keep_config"] = flattenBool(&in.KeepConfig)
		}

		if 	in.LB != "" {
			out[i]["lb"] = flattenString(in.LB)
		}

		if 	in.LabelPrefixFile != "" {
			out[i]["label_prefix_file"] = flattenString(in.LabelPrefixFile)
		}

		if 	in.Labels != nil {
			out[i]["labels"] = flattenStringSlice(in.Labels)
		}

		if 	in.LibDir != "" {
			out[i]["lib_dir"] = flattenString(in.LibDir)
		}

		if 	in.LogDrivers != nil {
			out[i]["log_driver"] = flattenStringSlice(in.LogDrivers)
		}

		if 	in.LogOpt != nil {
			out[i]["log_opt"] = flattenStringMap(in.LogOpt)
		}

		if 	in.Logstash {
			out[i]["logstash"] = flattenBool(&in.Logstash)
		}

		if 	in.LogstashAgent != "" {
			out[i]["logstash_agent"] = flattenString(in.LogstashAgent)
		}

		if 	in.LogstashProbeTimer != 0 {
			out[i]["logstash_probe_timer"] = flattenUint32(in.LogstashProbeTimer)
		}

		out[i]["monitor_aggregation"] = flattenString(in.MonitorAggregation)

		if 	in.Nat46Range != "" {
			out[i]["nat_46range"] = flattenString(in.Nat46Range)
		}

		out[i]["node_init_bootstrap_file"] = flattenString(in.NodeInitBootstrapFile)

		if 	in.Pprof {
			out[i]["pprof"] = flattenBool(&in.Pprof)
		}

		out[i]["preallocate_bpf_maps"] = flattenBool(&in.PreallocateBPFMaps)

		if 	in.PrefilterDevice != "" {
			out[i]["prefilter_device"] = flattenString(in.PrefilterDevice)
		}

		if 	in.PrometheusServeAddr != "" {
			out[i]["prometheus_serve_addr"] = flattenString(in.PrometheusServeAddr)
		}

		out[i]["reconfigure_kubelet"] = flattenBool(&in.ReconfigureKubelet)

		out[i]["remove_cbr_bridge"] = flattenBool(&in.RemoveCbrBridge)

		out[i]["restart_pods"] = flattenBool(&in.RestartPods)

		if 	in.Restore {
			out[i]["restore"] = flattenBool(&in.Restore)
		}

		out[i]["sidecar_istio_proxy_image"] = flattenString(in.SidecarIstioProxyImage)

		if 	in.SingleClusterRoute {
			out[i]["single_cluster_route"] = flattenBool(&in.SingleClusterRoute)
		}

		if 	in.SocketPath != "" {
			out[i]["socket_path"] = flattenString(in.SocketPath)
		}

		if 	in.StateDir != "" {
			out[i]["state_dir"] = flattenString(in.StateDir)
		}

		out[i]["to_fqdns_enable_poller"] = flattenBool(&in.ToFqdnsEnablePoller)

		if 	in.TracePayloadLen != 0 {
			out[i]["trace_payloadlen"] = flattenInt(in.TracePayloadLen)
		}

		if 	in.Tunnel != "" {
			out[i]["tunnel"] = flattenString(in.Tunnel)
		}

		if 	in.Version != "" {
			out[i]["version"] = flattenString(in.Version)
		}
	}

	return out
}

func flattenClassicNetworkingSpec(in *kops.ClassicNetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenCloudConfiguration(in *kops.CloudConfiguration) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.DisableSecurityGroupIngress {
			out[i]["disable_security_group_ingress"] = flattenBool(in.DisableSecurityGroupIngress)
		}

		if 	*in.ElbSecurityGroup != "" {
			out[i]["elb_security_group"] = flattenString(*in.ElbSecurityGroup)
		}

		if 	*in.Multizone {
			out[i]["multizone"] = flattenBool(in.Multizone)
		}

		if 	*in.NodeInstancePrefix != "" {
			out[i]["node_instance_prefix"] = flattenString(*in.NodeInstancePrefix)
		}

		if 	*in.NodeTags != "" {
			out[i]["node_tags"] = flattenString(*in.NodeTags)
		}

		if 	in.Openstack != nil {
			out[i]["openstack"] = flattenOpenstackConfiguration(in.Openstack)
		}

		if 	*in.SpotinstOrientation != "" {
			out[i]["spotinst_orientation"] = flattenString(*in.SpotinstOrientation)
		}

		if 	*in.SpotinstProduct != "" {
			out[i]["spotinst_product"] = flattenString(*in.SpotinstProduct)
		}

		if 	*in.VSphereCoreDNSServer != "" {
			out[i]["v_sphere_core_dns_server"] = flattenString(*in.VSphereCoreDNSServer)
		}

		if 	*in.VSphereDatacenter != "" {
			out[i]["v_sphere_datacenter"] = flattenString(*in.VSphereDatacenter)
		}

		if 	*in.VSphereDatastore != "" {
			out[i]["v_sphere_datastore"] = flattenString(*in.VSphereDatastore)
		}

		if 	*in.VSpherePassword != "" {
			out[i]["v_sphere_password"] = flattenString(*in.VSpherePassword)
		}

		if 	*in.VSphereResourcePool != "" {
			out[i]["v_sphere_resource_pool"] = flattenString(*in.VSphereResourcePool)
		}

		if 	*in.VSphereServer != "" {
			out[i]["v_sphere_server"] = flattenString(*in.VSphereServer)
		}

		if 	*in.VSphereUsername != "" {
			out[i]["v_sphere_username"] = flattenString(*in.VSphereUsername)
		}
	}

	return out
}

func flattenCloudControllerManagerConfig(in *kops.CloudControllerManagerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.AllocateNodeCIDRs {
			out[i]["allocate_node_cid_rss"] = flattenBool(in.AllocateNodeCIDRs)
		}

		if 	*in.CIDRAllocatorType != "" {
			out[i]["cidr_allocator_type"] = flattenString(*in.CIDRAllocatorType)
		}

		if 	in.CloudProvider != "" {
			out[i]["cloud_provider"] = flattenString(in.CloudProvider)
		}

		if 	in.ClusterCIDR != "" {
			out[i]["cluster_cidr"] = flattenString(in.ClusterCIDR)
		}

		if 	in.ClusterName != "" {
			out[i]["cluster_name"] = flattenString(in.ClusterName)
		}

		if 	*in.ConfigureCloudRoutes {
			out[i]["configure_cloud_routes"] = flattenBool(in.ConfigureCloudRoutes)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.LeaderElection != nil {
			out[i]["leader_election"] = flattenLeaderElectionConfiguration(in.LeaderElection)
		}

		if 	in.LogLevel != 0 {
			out[i]["log_level"] = flattenInt32(in.LogLevel)
		}

		if 	in.Master != "" {
			out[i]["master"] = flattenString(in.Master)
		}

		if 	*in.UseServiceAccountCredentials {
			out[i]["use_service_account_credentials"] = flattenBool(in.UseServiceAccountCredentials)
		}
	}

	return out
}

func flattenClusterSpec(in kops.ClusterSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.API != nil {
			out[i]["api"] = flattenAccessSpec(in.API)
		}

		if 	in.AdditionalNetworkCIDRs != nil {
			out[i]["additional_network_cid_rss"] = flattenStringSlice(in.AdditionalNetworkCIDRs)
		}

		if 	*in.AdditionalPolicies != nil {
			out[i]["additional_policies"] = flattenStringMap(*in.AdditionalPolicies)
		}

		if 	in.AdditionalSANs != nil {
			out[i]["additional_sans"] = flattenStringSlice(in.AdditionalSANs)
		}

		if 	in.Addons != nil {
			out[i]["addons"] = flattenAddonSpecSlice(in.Addons)
		}

		if 	in.Assets != nil {
			out[i]["assets"] = flattenAssets(in.Assets)
		}

		if 	in.Authentication != nil {
			out[i]["authentication"] = flattenAuthenticationSpec(in.Authentication)
		}

		if 	in.Authorization != nil {
			out[i]["authorization"] = flattenAuthorizationSpec(in.Authorization)
		}

		if 	in.Channel != "" {
			out[i]["channel"] = flattenString(in.Channel)
		}

		if 	in.CloudConfig != nil {
			out[i]["cloud_config"] = flattenCloudConfiguration(in.CloudConfig)
		}

		if 	in.CloudLabels != nil {
			out[i]["cloud_labels"] = flattenStringMap(in.CloudLabels)
		}

		if 	in.CloudProvider != "" {
			out[i]["cloud_provider"] = flattenString(in.CloudProvider)
		}

		if 	in.ClusterDNSDomain != "" {
			out[i]["cluster_dns_domain"] = flattenString(in.ClusterDNSDomain)
		}

		if 	in.ConfigBase != "" {
			out[i]["config_base"] = flattenString(in.ConfigBase)
		}

		if 	in.ConfigStore != "" {
			out[i]["config_store"] = flattenString(in.ConfigStore)
		}

		if 	in.DNSZone != "" {
			out[i]["dns_zone"] = flattenString(in.DNSZone)
		}

		if 	in.DisableSubnetTags {
			out[i]["disable_subnet_tags"] = flattenBool(&in.DisableSubnetTags)
		}

		if 	in.Docker != nil {
			out[i]["docker"] = flattenDockerConfig(in.Docker)
		}

		if 	in.EgressProxy != nil {
			out[i]["egress_proxy"] = flattenEgressProxySpec(in.EgressProxy)
		}

		if 	*in.EncryptionConfig {
			out[i]["encryption_config"] = flattenBool(in.EncryptionConfig)
		}

		if 	in.EtcdClusters != nil {
			out[i]["etcd_clusters"] = flattenEtcdClusterSpecSlice(in.EtcdClusters)
		}

		if 	in.ExternalCloudControllerManager != nil {
			out[i]["cloud_controller_manager"] = flattenCloudControllerManagerConfig(in.ExternalCloudControllerManager)
		}

		if 	in.ExternalDNS != nil {
			out[i]["external_dns"] = flattenExternalDNSConfig(in.ExternalDNS)
		}

		if 	in.FileAssets != nil {
			out[i]["file_assets"] = flattenFileAssetSpecSlice(in.FileAssets)
		}

		if 	in.Hooks != nil {
			out[i]["hooks"] = flattenHookSpecSlice(in.Hooks)
		}

		if 	in.IAM != nil {
			out[i]["iam"] = flattenIAMSpec(in.IAM)
		}

		if 	*in.IsolateMasters {
			out[i]["isolate_masters"] = flattenBool(in.IsolateMasters)
		}

		if 	in.KeyStore != "" {
			out[i]["key_store"] = flattenString(in.KeyStore)
		}

		if 	in.KubeAPIServer != nil {
			out[i]["kube_api_server"] = flattenKubeAPIServerConfig(in.KubeAPIServer)
		}

		if 	in.KubeControllerManager != nil {
			out[i]["kube_controller_manager"] = flattenKubeControllerManagerConfig(in.KubeControllerManager)
		}

		if 	in.KubeDNS != nil {
			out[i]["kube_dns"] = flattenKubeDNSConfig(in.KubeDNS)
		}

		if 	in.KubeProxy != nil {
			out[i]["kube_proxy"] = flattenKubeProxyConfig(in.KubeProxy)
		}

		if 	in.KubeScheduler != nil {
			out[i]["kube_scheduler"] = flattenKubeSchedulerConfig(in.KubeScheduler)
		}

		if 	in.Kubelet != nil {
			out[i]["kubelet"] = flattenKubeletConfigSpec(in.Kubelet)
		}

		if 	in.KubernetesAPIAccess != nil {
			out[i]["kubernetes_api_access"] = flattenStringSlice(in.KubernetesAPIAccess)
		}

		if 	in.KubernetesVersion != "" {
			out[i]["kubernetes_version"] = flattenString(in.KubernetesVersion)
		}

		if 	in.MasterInternalName != "" {
			out[i]["master_internal_name"] = flattenString(in.MasterInternalName)
		}

		if 	in.MasterKubelet != nil {
			out[i]["master_kubelet"] = flattenKubeletConfigSpec(in.MasterKubelet)
		}

		if 	in.MasterPublicName != "" {
			out[i]["master_public_name"] = flattenString(in.MasterPublicName)
		}

		if 	in.NetworkCIDR != "" {
			out[i]["network_cidr"] = flattenString(in.NetworkCIDR)
		}

		if 	in.NetworkID != "" {
			out[i]["network_id"] = flattenString(in.NetworkID)
		}

		if 	in.Networking != nil {
			out[i]["networking"] = flattenNetworkingSpec(in.Networking)
		}

		if 	in.NodeAuthorization != nil {
			out[i]["node_authorization"] = flattenNodeAuthorizationSpec(in.NodeAuthorization)
		}

		if 	in.NodePortAccess != nil {
			out[i]["node_port_access"] = flattenStringSlice(in.NodePortAccess)
		}

		if 	in.NonMasqueradeCIDR != "" {
			out[i]["non_masquerade_cidr"] = flattenString(in.NonMasqueradeCIDR)
		}

		if 	in.PodCIDR != "" {
			out[i]["pod_cidr"] = flattenString(in.PodCIDR)
		}

		if 	in.Project != "" {
			out[i]["project"] = flattenString(in.Project)
		}

		if 	in.SSHAccess != nil {
			out[i]["ssh_access"] = flattenStringSlice(in.SSHAccess)
		}

		if 	in.SSHKeyName != "" {
			out[i]["ssh_key_name"] = flattenString(in.SSHKeyName)
		}

		if 	in.SecretStore != "" {
			out[i]["secret_store"] = flattenString(in.SecretStore)
		}

		if 	in.ServiceClusterIPRange != "" {
			out[i]["service_cluster_ip_range"] = flattenString(in.ServiceClusterIPRange)
		}

		if 	in.Subnets != nil {
			out[i]["subnets"] = flattenClusterSubnetSpecSlice(in.Subnets)
		}

		if 	in.Target != nil {
			out[i]["target"] = flattenTargetSpec(in.Target)
		}

		if 	in.Topology != nil {
			out[i]["topology"] = flattenTopologySpec(in.Topology)
		}

		if 	*in.UpdatePolicy != "" {
			out[i]["update_policy"] = flattenString(*in.UpdatePolicy)
		}
	}

	return out
}

func flattenClusterSubnetSpecSlice(in []kops.ClusterSubnetSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].CIDR != "" {
			out[i]["cidr"] = flattenString(in[i].CIDR)
		}

		if 	in[i].Egress != "" {
			out[i]["egress"] = flattenString(in[i].Egress)
		}

		if 	in[i].Name != "" {
			out[i]["name"] = flattenString(in[i].Name)
		}

		if 	in[i].ProviderID != "" {
			out[i]["id"] = flattenString(in[i].ProviderID)
		}

		if 	in[i].PublicIP != "" {
			out[i]["public_ip"] = flattenString(in[i].PublicIP)
		}

		if 	in[i].Region != "" {
			out[i]["region"] = flattenString(in[i].Region)
		}

		if 	in[i].Type != "" {
			out[i]["type"] = flattenSubnetType(in[i].Type)
		}

		if 	in[i].Zone != "" {
			out[i]["zone"] = flattenString(in[i].Zone)
		}
	}

	return out
}

func flattenDNSAccessSpec(in *kops.DNSAccessSpec) interface{} {
	out := *in

	return out
}

func flattenDNSSpec(in *kops.DNSSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Type != "" {
			out[i]["type"] = flattenDNSType(in.Type)
		}
	}

	return out
}

func flattenDNSType(in kops.DNSType) interface{} {
	out := in

	return out
}

func flattenDockerConfig(in *kops.DockerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AuthorizationPlugins != nil {
			out[i]["authorization_plugins"] = flattenStringSlice(in.AuthorizationPlugins)
		}

		if 	*in.Bridge != "" {
			out[i]["bridge"] = flattenString(*in.Bridge)
		}

		if 	*in.BridgeIP != "" {
			out[i]["bridge_ip"] = flattenString(*in.BridgeIP)
		}

		if 	*in.DataRoot != "" {
			out[i]["data_root"] = flattenString(*in.DataRoot)
		}

		if 	in.DefaultUlimit != nil {
			out[i]["default_ulimit"] = flattenStringSlice(in.DefaultUlimit)
		}

		if 	in.ExecOpt != nil {
			out[i]["exec_opt"] = flattenStringSlice(in.ExecOpt)
		}

		if 	*in.ExecRoot != "" {
			out[i]["exec_root"] = flattenString(*in.ExecRoot)
		}

		if 	*in.Experimental {
			out[i]["experimental"] = flattenBool(in.Experimental)
		}

		if 	in.Hosts != nil {
			out[i]["hosts"] = flattenStringSlice(in.Hosts)
		}

		if 	*in.IPMasq {
			out[i]["ip_masq"] = flattenBool(in.IPMasq)
		}

		if 	*in.IPTables {
			out[i]["ip_tables"] = flattenBool(in.IPTables)
		}

		if 	in.InsecureRegistries != nil {
			out[i]["insecure_registries"] = flattenStringSlice(in.InsecureRegistries)
		}

		if 	*in.InsecureRegistry != "" {
			out[i]["insecure_registry"] = flattenString(*in.InsecureRegistry)
		}

		if 	*in.LiveRestore {
			out[i]["live_restore"] = flattenBool(in.LiveRestore)
		}

		if 	*in.LogDriver != "" {
			out[i]["log_driver"] = flattenString(*in.LogDriver)
		}

		if 	*in.LogLevel != "" {
			out[i]["log_level"] = flattenString(*in.LogLevel)
		}

		if 	in.LogOpt != nil {
			out[i]["log_opt"] = flattenStringSlice(in.LogOpt)
		}

		if 	*in.MTU != 0 {
			out[i]["mtu"] = flattenInt32(*in.MTU)
		}

		if 	*in.MetricsAddress != "" {
			out[i]["metrics_address"] = flattenString(*in.MetricsAddress)
		}

		if 	in.RegistryMirrors != nil {
			out[i]["registry_mirrors"] = flattenStringSlice(in.RegistryMirrors)
		}

		if 	in.SkipInstall {
			out[i]["skip_install"] = flattenBool(&in.SkipInstall)
		}

		if 	*in.Storage != "" {
			out[i]["storage"] = flattenString(*in.Storage)
		}

		if 	in.StorageOpts != nil {
			out[i]["storage_opts"] = flattenStringSlice(in.StorageOpts)
		}

		if 	in.UserNamespaceRemap != "" {
			out[i]["user_namespace_remap"] = flattenString(in.UserNamespaceRemap)
		}

		if 	*in.Version != "" {
			out[i]["version"] = flattenString(*in.Version)
		}
	}

	return out
}

func flattenEgressProxySpec(in *kops.EgressProxySpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.HTTPProxy != (kops.HTTPProxy{}) {
			out[i]["http_proxy"] = flattenHTTPProxy(in.HTTPProxy)
		}

		if 	in.ProxyExcludes != "" {
			out[i]["excludes"] = flattenString(in.ProxyExcludes)
		}
	}

	return out
}

func flattenEtcdBackupSpec(in *kops.EtcdBackupSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.BackupStore != "" {
			out[i]["backup_store"] = flattenString(in.BackupStore)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}
	}

	return out
}

func flattenEtcdClusterSpecSlice(in []*kops.EtcdClusterSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Backups != nil {
			out[i]["backups"] = flattenEtcdBackupSpec(in[i].Backups)
		}

		if 	in[i].CPURequest != nil {
			out[i]["cpu_request"] = flattenQuantity(in[i].CPURequest)
		}

		if 	in[i].EnableEtcdTLS {
			out[i]["enable_etcd_tls"] = flattenBool(&in[i].EnableEtcdTLS)
		}

		if 	in[i].EnableTLSAuth {
			out[i]["enable_tls_auth"] = flattenBool(&in[i].EnableTLSAuth)
		}

		if 	in[i].HeartbeatInterval != nil {
			out[i]["heartbeat_interval"] = flattenDuration(in[i].HeartbeatInterval)
		}

		if 	in[i].Image != "" {
			out[i]["image"] = flattenString(in[i].Image)
		}

		if 	in[i].LeaderElectionTimeout != nil {
			out[i]["leader_election_timeout"] = flattenDuration(in[i].LeaderElectionTimeout)
		}

		if 	in[i].Manager != nil {
			out[i]["manager"] = flattenEtcdManagerSpec(in[i].Manager)
		}

		if 	in[i].Members != nil {
			out[i]["etcd_members"] = flattenEtcdMemberSpecSlice(in[i].Members)
		}

		if 	in[i].MemoryRequest != nil {
			out[i]["memory_request"] = flattenQuantity(in[i].MemoryRequest)
		}

		if 	in[i].Name != "" {
			out[i]["name"] = flattenString(in[i].Name)
		}

		if 	in[i].Provider != "" {
			out[i]["provider"] = flattenEtcdProviderType(in[i].Provider)
		}

		if 	in[i].Version != "" {
			out[i]["version"] = flattenString(in[i].Version)
		}
	}

	return out
}

func flattenEtcdManagerSpec(in *kops.EtcdManagerSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}
	}

	return out
}

func flattenEtcdMemberSpecSlice(in []*kops.EtcdMemberSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in[i].EncryptedVolume {
			out[i]["encrypted_volume"] = flattenBool(in[i].EncryptedVolume)
		}

		if 	*in[i].InstanceGroup != "" {
			out[i]["instance_group"] = flattenString(*in[i].InstanceGroup)
		}

		if 	*in[i].KmsKeyId != "" {
			out[i]["kms_key_id"] = flattenString(*in[i].KmsKeyId)
		}

		if 	in[i].Name != "" {
			out[i]["name"] = flattenString(in[i].Name)
		}

		if 	*in[i].VolumeIops != 0 {
			out[i]["volume_iops"] = flattenInt32(*in[i].VolumeIops)
		}

		if 	*in[i].VolumeSize != 0 {
			out[i]["volume_size"] = flattenInt32(*in[i].VolumeSize)
		}

		if 	*in[i].VolumeType != "" {
			out[i]["volume_type"] = flattenString(*in[i].VolumeType)
		}
	}

	return out
}

func flattenEtcdProviderType(in kops.EtcdProviderType) interface{} {
	out := in

	return out
}

func flattenExecContainerAction(in *kops.ExecContainerAction) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Command != nil {
			out[i]["command"] = flattenStringSlice(in.Command)
		}

		if 	in.Environment != nil {
			out[i]["environment"] = flattenStringMap(in.Environment)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}
	}

	return out
}

func flattenExternalDNSConfig(in *kops.ExternalDNSConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Disable {
			out[i]["disable"] = flattenBool(&in.Disable)
		}

		if 	*in.WatchIngress {
			out[i]["watch_ingress"] = flattenBool(in.WatchIngress)
		}

		if 	in.WatchNamespace != "" {
			out[i]["watch_namespace"] = flattenString(in.WatchNamespace)
		}
	}

	return out
}

func flattenExternalNetworkingSpec(in *kops.ExternalNetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenFields(in *v1.Fields) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})
	
		{
			m := flattenFieldsMap(in.Map)

			for k, v := range m {
				out[i][k] = v
			}
		}
	}

	return out
}

func flattenFieldsMap(in map[string]v1.Fields) map[string]interface{} {
	out := make(map[string]interface{})

	for k, v := range in {
		out[k] = v
	}

	return out
}

func flattenFlannelNetworkingSpec(in *kops.FlannelNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Backend != "" {
			out[i]["backend"] = flattenString(in.Backend)
		}

		if 	*in.IptablesResyncSeconds != 0 {
			out[i]["iptables_resync_seconds"] = flattenInt32(*in.IptablesResyncSeconds)
		}
	}

	return out
}

func flattenFloat32(in *float32) interface{} {
	out := *in

	return out
}

func flattenFloat64(in *float64) interface{} {
	out := *in

	return out
}

func flattenFormat(in resource.Format) interface{} {
	out := in

	return out
}

func flattenGCENetworkingSpec(in *kops.GCENetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenHTTPProxy(in kops.HTTPProxy) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Host != "" {
			out[i]["host"] = flattenString(in.Host)
		}

		if 	in.Port != 0 {
			out[i]["port"] = flattenInt(in.Port)
		}
	}

	return out
}

func flattenIAMSpec(in *kops.IAMSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AllowContainerRegistry {
			out[i]["allow_container_registry"] = flattenBool(&in.AllowContainerRegistry)
		}

		out[i]["legacy"] = flattenBool(&in.Legacy)
	}

	return out
}

func flattenInitializerSlice(in []v1.Initializer) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		out[i]["name"] = flattenString(in[i].Name)
	}

	return out
}

func flattenInstanceGroupRoleSlice(in []kops.InstanceGroupRole) []interface{} {
	out := make([]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = in[i]
	}

	return out
}

func flattenInt(in int) interface{} {
	out := in

	return out
}

func flattenKopeioAuthenticationSpec(in *kops.KopeioAuthenticationSpec) interface{} {
	out := *in

	return out
}

func flattenKopeioNetworkingSpec(in *kops.KopeioNetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenKubeAPIServerConfig(in *kops.KubeAPIServerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.APIAudiences != nil {
			out[i]["api_audiences"] = flattenStringSlice(in.APIAudiences)
		}

		if 	*in.APIServerCount != 0 {
			out[i]["api_server_count"] = flattenInt32(*in.APIServerCount)
		}

		if 	in.Address != "" {
			out[i]["address"] = flattenString(in.Address)
		}

		if 	in.AdmissionControl != nil {
			out[i]["admission_control"] = flattenStringSlice(in.AdmissionControl)
		}

		if 	in.AdmissionControlConfigFile != "" {
			out[i]["admission_control_config_file"] = flattenString(in.AdmissionControlConfigFile)
		}

		if 	*in.AllowPrivileged {
			out[i]["allow_privileged"] = flattenBool(in.AllowPrivileged)
		}

		if 	*in.AnonymousAuth {
			out[i]["anonymous_auth"] = flattenBool(in.AnonymousAuth)
		}

		if 	in.AppendAdmissionPlugins != nil {
			out[i]["append_admission_plugins"] = flattenStringSlice(in.AppendAdmissionPlugins)
		}

		if 	*in.AuditLogFormat != "" {
			out[i]["audit_log_format"] = flattenString(*in.AuditLogFormat)
		}

		if 	*in.AuditLogMaxAge != 0 {
			out[i]["audit_log_max_age"] = flattenInt32(*in.AuditLogMaxAge)
		}

		if 	*in.AuditLogMaxBackups != 0 {
			out[i]["audit_log_max_backups"] = flattenInt32(*in.AuditLogMaxBackups)
		}

		if 	*in.AuditLogMaxSize != 0 {
			out[i]["audit_log_max_size"] = flattenInt32(*in.AuditLogMaxSize)
		}

		if 	*in.AuditLogPath != "" {
			out[i]["audit_log_path"] = flattenString(*in.AuditLogPath)
		}

		if 	in.AuditPolicyFile != "" {
			out[i]["audit_policy_file"] = flattenString(in.AuditPolicyFile)
		}

		if 	*in.AuditWebhookBatchBufferSize != 0 {
			out[i]["audit_webhook_batch_buffer_size"] = flattenInt32(*in.AuditWebhookBatchBufferSize)
		}

		if 	*in.AuditWebhookBatchMaxSize != 0 {
			out[i]["audit_webhook_batch_max_size"] = flattenInt32(*in.AuditWebhookBatchMaxSize)
		}

		if 	in.AuditWebhookBatchMaxWait != nil {
			out[i]["audit_webhook_batch_max_wait"] = flattenDuration(in.AuditWebhookBatchMaxWait)
		}

		if 	*in.AuditWebhookBatchThrottleBurst != 0 {
			out[i]["audit_webhook_batch_throttle_burst"] = flattenInt32(*in.AuditWebhookBatchThrottleBurst)
		}

		if 	*in.AuditWebhookBatchThrottleEnable {
			out[i]["audit_webhook_batch_throttle_enable"] = flattenBool(in.AuditWebhookBatchThrottleEnable)
		}

		if 	in.AuditWebhookBatchThrottleQps != nil {
			out[i]["audit_webhook_batch_throttle_qps"] = flattenFloat32(in.AuditWebhookBatchThrottleQps)
		}

		if 	in.AuditWebhookConfigFile != "" {
			out[i]["audit_webhook_config_file"] = flattenString(in.AuditWebhookConfigFile)
		}

		if 	in.AuditWebhookInitialBackoff != nil {
			out[i]["audit_webhook_initial_backoff"] = flattenDuration(in.AuditWebhookInitialBackoff)
		}

		if 	in.AuditWebhookMode != "" {
			out[i]["audit_webhook_mode"] = flattenString(in.AuditWebhookMode)
		}

		if 	in.AuthenticationTokenWebhookCacheTTL != nil {
			out[i]["authentication_token_webhook_cache_ttl"] = flattenDuration(in.AuthenticationTokenWebhookCacheTTL)
		}

		if 	*in.AuthenticationTokenWebhookConfigFile != "" {
			out[i]["authentication_token_webhook_config_file"] = flattenString(*in.AuthenticationTokenWebhookConfigFile)
		}

		if 	*in.AuthorizationMode != "" {
			out[i]["authorization_mode"] = flattenString(*in.AuthorizationMode)
		}

		if 	*in.AuthorizationRBACSuperUser != "" {
			out[i]["authorization_rbac_super_user"] = flattenString(*in.AuthorizationRBACSuperUser)
		}

		if 	in.AuthorizationWebhookCacheAuthorizedTTL != nil {
			out[i]["authorization_webhook_cache_authorized_ttl"] = flattenDuration(in.AuthorizationWebhookCacheAuthorizedTTL)
		}

		if 	in.AuthorizationWebhookCacheUnauthorizedTTL != nil {
			out[i]["authorization_webhook_cache_unauthorized_ttl"] = flattenDuration(in.AuthorizationWebhookCacheUnauthorizedTTL)
		}

		if 	*in.AuthorizationWebhookConfigFile != "" {
			out[i]["authorization_webhook_config_file"] = flattenString(*in.AuthorizationWebhookConfigFile)
		}

		if 	in.BasicAuthFile != "" {
			out[i]["basic_auth_file"] = flattenString(in.BasicAuthFile)
		}

		if 	in.BindAddress != "" {
			out[i]["bind_address"] = flattenString(in.BindAddress)
		}

		if 	in.CPURequest != "" {
			out[i]["cpu_request"] = flattenString(in.CPURequest)
		}

		if 	in.ClientCAFile != "" {
			out[i]["client_ca_file"] = flattenString(in.ClientCAFile)
		}

		if 	in.CloudProvider != "" {
			out[i]["cloud_provider"] = flattenString(in.CloudProvider)
		}

		if 	in.DisableAdmissionPlugins != nil {
			out[i]["disable_admission_plugins"] = flattenStringSlice(in.DisableAdmissionPlugins)
		}

		if 	in.DisableBasicAuth {
			out[i]["disable_basic_auth"] = flattenBool(&in.DisableBasicAuth)
		}

		if 	in.EnableAdmissionPlugins != nil {
			out[i]["enable_admission_plugins"] = flattenStringSlice(in.EnableAdmissionPlugins)
		}

		if 	*in.EnableAggregatorRouting {
			out[i]["enable_aggregator_routing"] = flattenBool(in.EnableAggregatorRouting)
		}

		if 	*in.EnableBootstrapAuthToken {
			out[i]["enable_bootstrap_token_auth"] = flattenBool(in.EnableBootstrapAuthToken)
		}

		if 	in.EtcdCAFile != "" {
			out[i]["etcd_ca_file"] = flattenString(in.EtcdCAFile)
		}

		if 	in.EtcdCertFile != "" {
			out[i]["etcd_cert_file"] = flattenString(in.EtcdCertFile)
		}

		if 	in.EtcdKeyFile != "" {
			out[i]["etcd_key_file"] = flattenString(in.EtcdKeyFile)
		}

		if 	*in.EtcdQuorumRead {
			out[i]["etcd_quorum_read"] = flattenBool(in.EtcdQuorumRead)
		}

		if 	in.EtcdServers != nil {
			out[i]["etcd_servers"] = flattenStringSlice(in.EtcdServers)
		}

		if 	in.EtcdServersOverrides != nil {
			out[i]["etcd_servers_overrides"] = flattenStringSlice(in.EtcdServersOverrides)
		}

		if 	in.EventTTL != nil {
			out[i]["event_ttl"] = flattenDuration(in.EventTTL)
		}

		if 	*in.ExperimentalEncryptionProviderConfig != "" {
			out[i]["experimental_encryption_provider_config"] = flattenString(*in.ExperimentalEncryptionProviderConfig)
		}

		if 	in.FeatureGates != nil {
			out[i]["feature_gates"] = flattenStringMap(in.FeatureGates)
		}

		if 	*in.HTTP2MaxStreamsPerConnection != 0 {
			out[i]["http_2max_streams_per_connection"] = flattenInt32(*in.HTTP2MaxStreamsPerConnection)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.InsecureBindAddress != "" {
			out[i]["insecure_bind_address"] = flattenString(in.InsecureBindAddress)
		}

		if 	in.InsecurePort != 0 {
			out[i]["insecure_port"] = flattenInt32(in.InsecurePort)
		}

		if 	in.KubeletClientCertificate != "" {
			out[i]["kubelet_client_certificate"] = flattenString(in.KubeletClientCertificate)
		}

		if 	in.KubeletClientKey != "" {
			out[i]["kubelet_client_key"] = flattenString(in.KubeletClientKey)
		}

		if 	in.KubeletPreferredAddressTypes != nil {
			out[i]["kubelet_preferred_address_types"] = flattenStringSlice(in.KubeletPreferredAddressTypes)
		}

		if 	in.LogLevel != 0 {
			out[i]["log_level"] = flattenInt32(in.LogLevel)
		}

		if 	in.MaxMutatingRequestsInflight != 0 {
			out[i]["max_mutating_requests_inflight"] = flattenInt32(in.MaxMutatingRequestsInflight)
		}

		if 	in.MaxRequestsInflight != 0 {
			out[i]["max_requests_inflight"] = flattenInt32(in.MaxRequestsInflight)
		}

		if 	*in.MinRequestTimeout != 0 {
			out[i]["min_request_timeout"] = flattenInt32(*in.MinRequestTimeout)
		}

		if 	*in.OIDCCAFile != "" {
			out[i]["oidc_ca_file"] = flattenString(*in.OIDCCAFile)
		}

		if 	*in.OIDCClientID != "" {
			out[i]["oidc_client_id"] = flattenString(*in.OIDCClientID)
		}

		if 	*in.OIDCGroupsClaim != "" {
			out[i]["oidc_groups_claim"] = flattenString(*in.OIDCGroupsClaim)
		}

		if 	*in.OIDCGroupsPrefix != "" {
			out[i]["oidc_groups_prefix"] = flattenString(*in.OIDCGroupsPrefix)
		}

		if 	*in.OIDCIssuerURL != "" {
			out[i]["oidc_issuer_url"] = flattenString(*in.OIDCIssuerURL)
		}

		if 	in.OIDCRequiredClaim != nil {
			out[i]["oidc_required_claim"] = flattenStringSlice(in.OIDCRequiredClaim)
		}

		if 	*in.OIDCUsernameClaim != "" {
			out[i]["oidc_username_claim"] = flattenString(*in.OIDCUsernameClaim)
		}

		if 	*in.OIDCUsernamePrefix != "" {
			out[i]["oidc_username_prefix"] = flattenString(*in.OIDCUsernamePrefix)
		}

		if 	*in.ProxyClientCertFile != "" {
			out[i]["proxy_client_cert_file"] = flattenString(*in.ProxyClientCertFile)
		}

		if 	*in.ProxyClientKeyFile != "" {
			out[i]["proxy_client_key_file"] = flattenString(*in.ProxyClientKeyFile)
		}

		if 	in.RequestheaderAllowedNames != nil {
			out[i]["requestheader_allowed_names"] = flattenStringSlice(in.RequestheaderAllowedNames)
		}

		if 	in.RequestheaderClientCAFile != "" {
			out[i]["requestheader_client_ca_file"] = flattenString(in.RequestheaderClientCAFile)
		}

		if 	in.RequestheaderExtraHeaderPrefixes != nil {
			out[i]["requestheader_extra_header_prefixes"] = flattenStringSlice(in.RequestheaderExtraHeaderPrefixes)
		}

		if 	in.RequestheaderGroupHeaders != nil {
			out[i]["requestheader_group_headers"] = flattenStringSlice(in.RequestheaderGroupHeaders)
		}

		if 	in.RequestheaderUsernameHeaders != nil {
			out[i]["requestheader_username_headers"] = flattenStringSlice(in.RequestheaderUsernameHeaders)
		}

		if 	in.RuntimeConfig != nil {
			out[i]["runtime_config"] = flattenStringMap(in.RuntimeConfig)
		}

		if 	in.SecurePort != 0 {
			out[i]["secure_port"] = flattenInt32(in.SecurePort)
		}

		if 	*in.ServiceAccountIssuer != "" {
			out[i]["service_account_issuer"] = flattenString(*in.ServiceAccountIssuer)
		}

		if 	in.ServiceAccountKeyFile != nil {
			out[i]["service_account_key_file"] = flattenStringSlice(in.ServiceAccountKeyFile)
		}

		if 	*in.ServiceAccountSigningKeyFile != "" {
			out[i]["service_account_signing_key_file"] = flattenString(*in.ServiceAccountSigningKeyFile)
		}

		if 	in.ServiceClusterIPRange != "" {
			out[i]["service_cluster_ip_range"] = flattenString(in.ServiceClusterIPRange)
		}

		if 	in.ServiceNodePortRange != "" {
			out[i]["service_node_port_range"] = flattenString(in.ServiceNodePortRange)
		}

		if 	*in.StorageBackend != "" {
			out[i]["storage_backend"] = flattenString(*in.StorageBackend)
		}

		if 	in.TLSCertFile != "" {
			out[i]["tls_cert_file"] = flattenString(in.TLSCertFile)
		}

		if 	in.TLSCipherSuites != nil {
			out[i]["tls_cipher_suites"] = flattenStringSlice(in.TLSCipherSuites)
		}

		if 	in.TLSMinVersion != "" {
			out[i]["tls_min_version"] = flattenString(in.TLSMinVersion)
		}

		if 	in.TLSPrivateKeyFile != "" {
			out[i]["tls_private_key_file"] = flattenString(in.TLSPrivateKeyFile)
		}

		if 	in.TargetRamMb != 0 {
			out[i]["target_ram_mb"] = flattenInt32(in.TargetRamMb)
		}

		if 	in.TokenAuthFile != "" {
			out[i]["token_auth_file"] = flattenString(in.TokenAuthFile)
		}
	}

	return out
}

func flattenKubeControllerManagerConfig(in *kops.KubeControllerManagerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.AllocateNodeCIDRs {
			out[i]["allocate_node_cid_rss"] = flattenBool(in.AllocateNodeCIDRs)
		}

		if 	in.AttachDetachReconcileSyncPeriod != nil {
			out[i]["attach_detach_reconcile_sync_period"] = flattenDuration(in.AttachDetachReconcileSyncPeriod)
		}

		if 	*in.CIDRAllocatorType != "" {
			out[i]["cidr_allocator_type"] = flattenString(*in.CIDRAllocatorType)
		}

		if 	in.CloudProvider != "" {
			out[i]["cloud_provider"] = flattenString(in.CloudProvider)
		}

		if 	in.ClusterCIDR != "" {
			out[i]["cluster_cidr"] = flattenString(in.ClusterCIDR)
		}

		if 	in.ClusterName != "" {
			out[i]["cluster_name"] = flattenString(in.ClusterName)
		}

		if 	*in.ConfigureCloudRoutes {
			out[i]["configure_cloud_routes"] = flattenBool(in.ConfigureCloudRoutes)
		}

		if 	in.Controllers != nil {
			out[i]["controllers"] = flattenStringSlice(in.Controllers)
		}

		if 	in.ExperimentalClusterSigningDuration != nil {
			out[i]["experimental_cluster_signing_duration"] = flattenDuration(in.ExperimentalClusterSigningDuration)
		}

		if 	in.FeatureGates != nil {
			out[i]["feature_gates"] = flattenStringMap(in.FeatureGates)
		}

		if 	in.HorizontalPodAutoscalerDownscaleDelay != nil {
			out[i]["horizontal_pod_autoscaler_downscale_delay"] = flattenDuration(in.HorizontalPodAutoscalerDownscaleDelay)
		}

		if 	in.HorizontalPodAutoscalerDownscaleStabilization != nil {
			out[i]["horizontal_pod_autoscaler_downscale_stabilization"] = flattenDuration(in.HorizontalPodAutoscalerDownscaleStabilization)
		}

		if 	in.HorizontalPodAutoscalerSyncPeriod != nil {
			out[i]["horizontal_pod_autoscaler_sync_period"] = flattenDuration(in.HorizontalPodAutoscalerSyncPeriod)
		}

		if 	in.HorizontalPodAutoscalerTolerance != nil {
			out[i]["horizontal_pod_autoscaler_tolerance"] = flattenFloat64(in.HorizontalPodAutoscalerTolerance)
		}

		if 	in.HorizontalPodAutoscalerUpscaleDelay != nil {
			out[i]["horizontal_pod_autoscaler_upscale_delay"] = flattenDuration(in.HorizontalPodAutoscalerUpscaleDelay)
		}

		if 	*in.HorizontalPodAutoscalerUseRestClients {
			out[i]["horizontal_pod_autoscaler_use_rest_clients"] = flattenBool(in.HorizontalPodAutoscalerUseRestClients)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	*in.KubeAPIBurst != 0 {
			out[i]["kube_api_burst"] = flattenInt32(*in.KubeAPIBurst)
		}

		if 	in.KubeAPIQPS != nil {
			out[i]["kube_apiqps"] = flattenFloat32(in.KubeAPIQPS)
		}

		if 	in.LeaderElection != nil {
			out[i]["leader_election"] = flattenLeaderElectionConfiguration(in.LeaderElection)
		}

		if 	in.LogLevel != 0 {
			out[i]["log_level"] = flattenInt32(in.LogLevel)
		}

		if 	in.Master != "" {
			out[i]["master"] = flattenString(in.Master)
		}

		if 	in.MinResyncPeriod != "" {
			out[i]["min_resync_period"] = flattenString(in.MinResyncPeriod)
		}

		if 	*in.NodeCIDRMaskSize != 0 {
			out[i]["node_cidr_mask_size"] = flattenInt32(*in.NodeCIDRMaskSize)
		}

		if 	in.NodeMonitorGracePeriod != nil {
			out[i]["node_monitor_grace_period"] = flattenDuration(in.NodeMonitorGracePeriod)
		}

		if 	in.NodeMonitorPeriod != nil {
			out[i]["node_monitor_period"] = flattenDuration(in.NodeMonitorPeriod)
		}

		if 	in.PodEvictionTimeout != nil {
			out[i]["pod_eviction_timeout"] = flattenDuration(in.PodEvictionTimeout)
		}

		if 	in.RootCAFile != "" {
			out[i]["root_ca_file"] = flattenString(in.RootCAFile)
		}

		if 	in.ServiceAccountPrivateKeyFile != "" {
			out[i]["service_account_private_key_file"] = flattenString(in.ServiceAccountPrivateKeyFile)
		}

		if 	in.TLSCipherSuites != nil {
			out[i]["tls_cipher_suites"] = flattenStringSlice(in.TLSCipherSuites)
		}

		if 	in.TLSMinVersion != "" {
			out[i]["tls_min_version"] = flattenString(in.TLSMinVersion)
		}

		if 	*in.TerminatedPodGCThreshold != 0 {
			out[i]["terminated_pod_gc_threshold"] = flattenInt32(*in.TerminatedPodGCThreshold)
		}

		if 	*in.UseServiceAccountCredentials {
			out[i]["use_service_account_credentials"] = flattenBool(in.UseServiceAccountCredentials)
		}
	}

	return out
}

func flattenKubeDNSConfig(in *kops.KubeDNSConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.CPURequest != nil {
			out[i]["cpu_request"] = flattenQuantity(in.CPURequest)
		}

		if 	in.CacheMaxConcurrent != 0 {
			out[i]["cache_max_concurrent"] = flattenInt(in.CacheMaxConcurrent)
		}

		if 	in.CacheMaxSize != 0 {
			out[i]["cache_max_size"] = flattenInt(in.CacheMaxSize)
		}

		if 	in.Domain != "" {
			out[i]["domain"] = flattenString(in.Domain)
		}

		if 	in.ExternalCoreFile != "" {
			out[i]["external_core_file"] = flattenString(in.ExternalCoreFile)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.MemoryLimit != nil {
			out[i]["memory_limit"] = flattenQuantity(in.MemoryLimit)
		}

		if 	in.MemoryRequest != nil {
			out[i]["memory_request"] = flattenQuantity(in.MemoryRequest)
		}

		if 	in.Provider != "" {
			out[i]["provider"] = flattenString(in.Provider)
		}

		if 	in.Replicas != 0 {
			out[i]["replicas"] = flattenInt(in.Replicas)
		}

		if 	in.ServerIP != "" {
			out[i]["server_ip"] = flattenString(in.ServerIP)
		}

		if 	in.StubDomains != nil {
			out[i]["stub_domains"] = flattenStringSliceMap(in.StubDomains)
		}

		if 	in.UpstreamNameservers != nil {
			out[i]["upstream_nameservers"] = flattenStringSlice(in.UpstreamNameservers)
		}
	}

	return out
}

func flattenKubeProxyConfig(in *kops.KubeProxyConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.BindAddress != "" {
			out[i]["bind_address"] = flattenString(in.BindAddress)
		}

		if 	in.CPULimit != "" {
			out[i]["cpu_limit"] = flattenString(in.CPULimit)
		}

		if 	in.CPURequest != "" {
			out[i]["cpu_request"] = flattenString(in.CPURequest)
		}

		if 	in.ClusterCIDR != "" {
			out[i]["cluster_cidr"] = flattenString(in.ClusterCIDR)
		}

		if 	*in.ConntrackMaxPerCore != 0 {
			out[i]["conntrack_max_per_core"] = flattenInt32(*in.ConntrackMaxPerCore)
		}

		if 	*in.ConntrackMin != 0 {
			out[i]["conntrack_min"] = flattenInt32(*in.ConntrackMin)
		}

		if 	*in.Enabled {
			out[i]["enabled"] = flattenBool(in.Enabled)
		}

		if 	in.FeatureGates != nil {
			out[i]["feature_gates"] = flattenStringMap(in.FeatureGates)
		}

		if 	in.HostnameOverride != "" {
			out[i]["hostname_override"] = flattenString(in.HostnameOverride)
		}

		if 	in.IPVSExcludeCIDRS != nil {
			out[i]["ipvs_exclude_cidrs"] = flattenStringSlice(in.IPVSExcludeCIDRS)
		}

		if 	in.IPVSMinSyncPeriod != nil {
			out[i]["ipvs_min_sync_period"] = flattenDuration(in.IPVSMinSyncPeriod)
		}

		if 	*in.IPVSScheduler != "" {
			out[i]["ipvs_scheduler"] = flattenString(*in.IPVSScheduler)
		}

		if 	in.IPVSSyncPeriod != nil {
			out[i]["ipvs_sync_period"] = flattenDuration(in.IPVSSyncPeriod)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.LogLevel != 0 {
			out[i]["log_level"] = flattenInt32(in.LogLevel)
		}

		if 	in.Master != "" {
			out[i]["master"] = flattenString(in.Master)
		}

		if 	in.MemoryLimit != "" {
			out[i]["memory_limit"] = flattenString(in.MemoryLimit)
		}

		if 	in.MemoryRequest != "" {
			out[i]["memory_request"] = flattenString(in.MemoryRequest)
		}

		if 	*in.MetricsBindAddress != "" {
			out[i]["metrics_bind_address"] = flattenString(*in.MetricsBindAddress)
		}

		if 	in.ProxyMode != "" {
			out[i]["proxy_mode"] = flattenString(in.ProxyMode)
		}
	}

	return out
}

func flattenKubeSchedulerConfig(in *kops.KubeSchedulerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.FeatureGates != nil {
			out[i]["feature_gates"] = flattenStringMap(in.FeatureGates)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.LeaderElection != nil {
			out[i]["leader_election"] = flattenLeaderElectionConfiguration(in.LeaderElection)
		}

		if 	in.LogLevel != 0 {
			out[i]["log_level"] = flattenInt32(in.LogLevel)
		}

		if 	in.Master != "" {
			out[i]["master"] = flattenString(in.Master)
		}

		if 	*in.MaxPersistentVolumes != 0 {
			out[i]["max_persistent_volumes"] = flattenInt32(*in.MaxPersistentVolumes)
		}

		if 	*in.UsePolicyConfigMap {
			out[i]["use_policy_config_map"] = flattenBool(in.UsePolicyConfigMap)
		}
	}

	return out
}

func flattenKubenetNetworkingSpec(in *kops.KubenetNetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenKuberouterNetworkingSpec(in *kops.KuberouterNetworkingSpec) interface{} {
	out := *in

	return out
}

func flattenLeaderElectionConfiguration(in *kops.LeaderElectionConfiguration) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.LeaderElect {
			out[i]["leader_elect"] = flattenBool(in.LeaderElect)
		}
	}

	return out
}

func flattenListMeta(in v1.ListMeta) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Continue != "" {
			out[i]["continue"] = flattenString(in.Continue)
		}

		if 	*in.RemainingItemCount != 0 {
			out[i]["remaining_item_count"] = flattenInt64(*in.RemainingItemCount)
		}

		if 	in.ResourceVersion != "" {
			out[i]["resource_version"] = flattenString(in.ResourceVersion)
		}

		if 	in.SelfLink != "" {
			out[i]["self_link"] = flattenString(in.SelfLink)
		}
	}

	return out
}

func flattenLoadBalancerAccessSpec(in *kops.LoadBalancerAccessSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AdditionalSecurityGroups != nil {
			out[i]["additional_security_groups"] = flattenStringSlice(in.AdditionalSecurityGroups)
		}

		if 	*in.CrossZoneLoadBalancing {
			out[i]["cross_zone_load_balancing"] = flattenBool(in.CrossZoneLoadBalancing)
		}

		if 	*in.IdleTimeoutSeconds != 0 {
			out[i]["idle_timeout_seconds"] = flattenInt64(*in.IdleTimeoutSeconds)
		}

		if 	in.SSLCertificate != "" {
			out[i]["ssl_certificate"] = flattenString(in.SSLCertificate)
		}

		if 	*in.SecurityGroupOverride != "" {
			out[i]["security_group_override"] = flattenString(*in.SecurityGroupOverride)
		}

		if 	in.Type != "" {
			out[i]["type"] = flattenLoadBalancerType(in.Type)
		}

		if 	in.UseForInternalApi {
			out[i]["use_for_internal_api"] = flattenBool(&in.UseForInternalApi)
		}
	}

	return out
}

func flattenLoadBalancerType(in kops.LoadBalancerType) interface{} {
	out := in

	return out
}

func flattenLyftVPCNetworkingSpec(in *kops.LyftVPCNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.SubnetTags != nil {
			out[i]["subnet_tags"] = flattenStringMap(in.SubnetTags)
		}
	}

	return out
}

func flattenManagedFieldsOperationType(in v1.ManagedFieldsOperationType) interface{} {
	out := in

	return out
}

func flattenNetworkingSpec(in *kops.NetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AmazonVPC != nil {
			out[i]["amazonvpc"] = flattenAmazonVPCNetworkingSpec(in.AmazonVPC)
		}

		if 	in.CNI != nil {
			out[i]["cni"] = flattenCNINetworkingSpec(in.CNI)
		}

		if 	in.Calico != nil {
			out[i]["calico"] = flattenCalicoNetworkingSpec(in.Calico)
		}

		if 	in.Canal != nil {
			out[i]["canal"] = flattenCanalNetworkingSpec(in.Canal)
		}

		if 	in.Cilium != nil {
			out[i]["cilium"] = flattenCiliumNetworkingSpec(in.Cilium)
		}

		if 	in.Classic != nil {
			out[i]["classic"] = flattenClassicNetworkingSpec(in.Classic)
		}

		if 	in.External != nil {
			out[i]["external"] = flattenExternalNetworkingSpec(in.External)
		}

		if 	in.Flannel != nil {
			out[i]["flannel"] = flattenFlannelNetworkingSpec(in.Flannel)
		}

		if 	in.GCE != nil {
			out[i]["gce"] = flattenGCENetworkingSpec(in.GCE)
		}

		if 	in.Kopeio != nil {
			out[i]["kopeio"] = flattenKopeioNetworkingSpec(in.Kopeio)
		}

		if 	in.Kubenet != nil {
			out[i]["kubenet"] = flattenKubenetNetworkingSpec(in.Kubenet)
		}

		if 	in.Kuberouter != nil {
			out[i]["kuberouter"] = flattenKuberouterNetworkingSpec(in.Kuberouter)
		}

		if 	in.LyftVPC != nil {
			out[i]["lyftvpc"] = flattenLyftVPCNetworkingSpec(in.LyftVPC)
		}

		if 	in.Romana != nil {
			out[i]["romana"] = flattenRomanaNetworkingSpec(in.Romana)
		}

		if 	in.Weave != nil {
			out[i]["weave"] = flattenWeaveNetworkingSpec(in.Weave)
		}
	}

	return out
}

func flattenNodeAuthorizationSpec(in *kops.NodeAuthorizationSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.NodeAuthorizer != nil {
			out[i]["node_authorizer"] = flattenNodeAuthorizerSpec(in.NodeAuthorizer)
		}
	}

	return out
}

func flattenNodeAuthorizerSpec(in *kops.NodeAuthorizerSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Authorizer != "" {
			out[i]["authorizer"] = flattenString(in.Authorizer)
		}

		if 	*in.Features != nil {
			out[i]["features"] = flattenStringSlice(*in.Features)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	in.Interval != nil {
			out[i]["interval"] = flattenDuration(in.Interval)
		}

		if 	in.NodeURL != "" {
			out[i]["node_url"] = flattenString(in.NodeURL)
		}

		if 	in.Port != 0 {
			out[i]["port"] = flattenInt(in.Port)
		}

		if 	in.Timeout != nil {
			out[i]["timeout"] = flattenDuration(in.Timeout)
		}

		if 	in.TokenTTL != nil {
			out[i]["token_ttl"] = flattenDuration(in.TokenTTL)
		}
	}

	return out
}

func flattenOpenstackBlockStorageConfig(in *kops.OpenstackBlockStorageConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.IgnoreAZ {
			out[i]["ignore_volume_az"] = flattenBool(in.IgnoreAZ)
		}

		if 	*in.OverrideAZ != "" {
			out[i]["override_volume_az"] = flattenString(*in.OverrideAZ)
		}

		if 	*in.Version != "" {
			out[i]["bs_version"] = flattenString(*in.Version)
		}
	}

	return out
}

func flattenOpenstackConfiguration(in *kops.OpenstackConfiguration) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.BlockStorage != nil {
			out[i]["block_storage"] = flattenOpenstackBlockStorageConfig(in.BlockStorage)
		}

		if 	*in.InsecureSkipVerify {
			out[i]["insecure_skip_verify"] = flattenBool(in.InsecureSkipVerify)
		}

		if 	in.Loadbalancer != nil {
			out[i]["loadbalancer"] = flattenOpenstackLoadbalancerConfig(in.Loadbalancer)
		}

		if 	in.Monitor != nil {
			out[i]["monitor"] = flattenOpenstackMonitor(in.Monitor)
		}

		if 	in.Router != nil {
			out[i]["router"] = flattenOpenstackRouter(in.Router)
		}
	}

	return out
}

func flattenOpenstackLoadbalancerConfig(in *kops.OpenstackLoadbalancerConfig) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.FloatingNetwork != "" {
			out[i]["floating_network"] = flattenString(*in.FloatingNetwork)
		}

		if 	*in.FloatingNetworkID != "" {
			out[i]["floating_network_id"] = flattenString(*in.FloatingNetworkID)
		}

		if 	*in.FloatingSubnet != "" {
			out[i]["floating_subnet"] = flattenString(*in.FloatingSubnet)
		}

		if 	*in.ManageSecGroups {
			out[i]["manage_security_groups"] = flattenBool(in.ManageSecGroups)
		}

		if 	*in.Method != "" {
			out[i]["method"] = flattenString(*in.Method)
		}

		if 	*in.Provider != "" {
			out[i]["provider"] = flattenString(*in.Provider)
		}

		if 	*in.SubnetID != "" {
			out[i]["subnet_id"] = flattenString(*in.SubnetID)
		}

		if 	*in.UseOctavia {
			out[i]["use_octavia"] = flattenBool(in.UseOctavia)
		}
	}

	return out
}

func flattenOpenstackMonitor(in *kops.OpenstackMonitor) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.Delay != "" {
			out[i]["delay"] = flattenString(*in.Delay)
		}

		if 	*in.MaxRetries != 0 {
			out[i]["max_retries"] = flattenInt(*in.MaxRetries)
		}

		if 	*in.Timeout != "" {
			out[i]["timeout"] = flattenString(*in.Timeout)
		}
	}

	return out
}

func flattenOpenstackRouter(in *kops.OpenstackRouter) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.DNSServers != "" {
			out[i]["dns_servers"] = flattenString(*in.DNSServers)
		}

		if 	*in.ExternalNetwork != "" {
			out[i]["external_network"] = flattenString(*in.ExternalNetwork)
		}

		if 	*in.ExternalSubnet != "" {
			out[i]["external_subnet"] = flattenString(*in.ExternalSubnet)
		}
	}

	return out
}

func flattenRBACAuthorizationSpec(in *kops.RBACAuthorizationSpec) interface{} {
	out := *in

	return out
}

func flattenRomanaNetworkingSpec(in *kops.RomanaNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.DaemonServiceIP != "" {
			out[i]["daemon_service_ip"] = flattenString(in.DaemonServiceIP)
		}

		if 	in.EtcdServiceIP != "" {
			out[i]["etcd_service_ip"] = flattenString(in.EtcdServiceIP)
		}
	}

	return out
}

func flattenStatus(in *v1.Status) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Code != 0 {
			out[i]["code"] = flattenInt32(in.Code)
		}

		if 	in.Details != nil {
			out[i]["details"] = flattenStatusDetails(in.Details)
		}

		if 	in.ListMeta != (v1.ListMeta{}) {
			out[i]["metadata"] = flattenListMeta(in.ListMeta)
		}

		if 	in.Message != "" {
			out[i]["message"] = flattenString(in.Message)
		}

		if 	in.Reason != "" {
			out[i]["reason"] = flattenStatusReason(in.Reason)
		}

		if 	in.Status != "" {
			out[i]["status"] = flattenString(in.Status)
		}
	
		{
			m := flattenTypeMeta(in.TypeMeta)

			for k, v := range m {
				out[i][k] = v
			}
		}
	}

	return out
}

func flattenStatusCauseSlice(in []v1.StatusCause) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Field != "" {
			out[i]["field"] = flattenString(in[i].Field)
		}

		if 	in[i].Message != "" {
			out[i]["message"] = flattenString(in[i].Message)
		}

		if 	in[i].Type != "" {
			out[i]["reason"] = flattenCauseType(in[i].Type)
		}
	}

	return out
}

func flattenStatusDetails(in *v1.StatusDetails) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Causes != nil {
			out[i]["causes"] = flattenStatusCauseSlice(in.Causes)
		}

		if 	in.Group != "" {
			out[i]["group"] = flattenString(in.Group)
		}

		if 	in.Kind != "" {
			out[i]["kind"] = flattenString(in.Kind)
		}

		if 	in.Name != "" {
			out[i]["name"] = flattenString(in.Name)
		}

		if 	in.RetryAfterSeconds != 0 {
			out[i]["retry_after_seconds"] = flattenInt32(in.RetryAfterSeconds)
		}

		if 	in.UID != "" {
			out[i]["uid"] = flattenUID(in.UID)
		}
	}

	return out
}

func flattenStatusReason(in v1.StatusReason) interface{} {
	out := in

	return out
}

func flattenStringSliceMap(in map[string][]string) map[string]interface{} {
	out := make(map[string]interface{})

	for k, v := range in {
		out[k] = v
	}

	return out
}

func flattenSubnetType(in kops.SubnetType) interface{} {
	out := in

	return out
}

func flattenTargetSpec(in *kops.TargetSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Terraform != nil {
			out[i]["terraform"] = flattenTerraformSpec(in.Terraform)
		}
	}

	return out
}

func flattenTerraformSpec(in *kops.TerraformSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.ProviderExtraConfig != nil {
			out[i]["provider_extra_config"] = flattenStringMap(*in.ProviderExtraConfig)
		}
	}

	return out
}

func flattenTopologySpec(in *kops.TopologySpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Bastion != nil {
			out[i]["bastion"] = flattenBastionSpec(in.Bastion)
		}

		if 	in.DNS != nil {
			out[i]["dns"] = flattenDNSSpec(in.DNS)
		}

		if 	in.Masters != "" {
			out[i]["masters"] = flattenString(in.Masters)
		}

		if 	in.Nodes != "" {
			out[i]["nodes"] = flattenString(in.Nodes)
		}
	}

	return out
}

func flattenUint32(in uint32) interface{} {
	out := in

	return out
}

func flattenWeaveNetworkingSpec(in *kops.WeaveNetworkingSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.ConnLimit != 0 {
			out[i]["conn_limit"] = flattenInt32(*in.ConnLimit)
		}

		if 	*in.MTU != 0 {
			out[i]["mtu"] = flattenInt32(*in.MTU)
		}

		if 	in.NetExtraArgs != "" {
			out[i]["net_extra_args"] = flattenString(in.NetExtraArgs)
		}

		if 	*in.NoMasqLocal != 0 {
			out[i]["no_masq_local"] = flattenInt32(*in.NoMasqLocal)
		}
	}

	return out
}
