// Code generated by engine.go; DO NOT EDIT.

package provider
import (
	"k8s.io/kops/pkg/apis/kops"
)


func flattenIAMProfileSpec(in *kops.IAMProfileSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in.Profile != "" {
			out[i]["profile"] = flattenString(*in.Profile)
		}
	}

	return out
}

func flattenInstanceGroupRole(in kops.InstanceGroupRole) interface{} {
	out := in

	return out
}

func flattenInstanceGroupSpec(in kops.InstanceGroupSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.AdditionalSecurityGroups != nil {
			out[i]["additional_security_groups"] = flattenStringSlice(in.AdditionalSecurityGroups)
		}

		if 	in.AdditionalUserData != nil {
			out[i]["additional_user_data"] = flattenUserDataSlice(in.AdditionalUserData)
		}

		if 	*in.AssociatePublicIP {
			out[i]["associate_public_ip"] = flattenBool(in.AssociatePublicIP)
		}

		if 	in.CloudLabels != nil {
			out[i]["cloud_labels"] = flattenStringMap(in.CloudLabels)
		}

		if 	*in.DetailedInstanceMonitoring {
			out[i]["detailed_instance_monitoring"] = flattenBool(in.DetailedInstanceMonitoring)
		}

		if 	in.ExternalLoadBalancers != nil {
			out[i]["external_load_balancers"] = flattenLoadBalancerSlice(in.ExternalLoadBalancers)
		}

		if 	in.FileAssets != nil {
			out[i]["file_assets"] = flattenFileAssetSpecSlice(in.FileAssets)
		}

		if 	in.Hooks != nil {
			out[i]["hooks"] = flattenHookSpecSlice(in.Hooks)
		}

		if 	in.IAM != nil {
			out[i]["iam"] = flattenIAMProfileSpec(in.IAM)
		}

		if 	in.Image != "" {
			out[i]["image"] = flattenString(in.Image)
		}

		if 	*in.InstanceProtection {
			out[i]["instance_protection"] = flattenBool(in.InstanceProtection)
		}

		if 	in.Kubelet != nil {
			out[i]["kubelet"] = flattenKubeletConfigSpec(in.Kubelet)
		}

		if 	in.MachineType != "" {
			out[i]["machine_type"] = flattenString(in.MachineType)
		}

		if 	*in.MaxPrice != "" {
			out[i]["max_price"] = flattenString(*in.MaxPrice)
		}

		if 	*in.MaxSize != 0 {
			out[i]["max_size"] = flattenInt32(*in.MaxSize)
		}

		if 	*in.MinSize != 0 {
			out[i]["min_size"] = flattenInt32(*in.MinSize)
		}

		if 	in.MixedInstancesPolicy != nil {
			out[i]["mixed_instances_policy"] = flattenMixedInstancesPolicySpec(in.MixedInstancesPolicy)
		}

		if 	in.NodeLabels != nil {
			out[i]["node_labels"] = flattenStringMap(in.NodeLabels)
		}

		if 	in.Role != "" {
			out[i]["role"] = flattenInstanceGroupRole(in.Role)
		}

		if 	*in.RootVolumeIops != 0 {
			out[i]["root_volume_iops"] = flattenInt32(*in.RootVolumeIops)
		}

		if 	*in.RootVolumeOptimization {
			out[i]["root_volume_optimization"] = flattenBool(in.RootVolumeOptimization)
		}

		if 	*in.RootVolumeSize != 0 {
			out[i]["root_volume_size"] = flattenInt32(*in.RootVolumeSize)
		}

		if 	*in.RootVolumeType != "" {
			out[i]["root_volume_type"] = flattenString(*in.RootVolumeType)
		}

		if 	*in.SecurityGroupOverride != "" {
			out[i]["security_group_override"] = flattenString(*in.SecurityGroupOverride)
		}

		if 	in.Subnets != nil {
			out[i]["subnets"] = flattenStringSlice(in.Subnets)
		}

		if 	in.SuspendProcesses != nil {
			out[i]["suspend_processes"] = flattenStringSlice(in.SuspendProcesses)
		}

		if 	in.Taints != nil {
			out[i]["taints"] = flattenStringSlice(in.Taints)
		}

		if 	in.Tenancy != "" {
			out[i]["tenancy"] = flattenString(in.Tenancy)
		}

		if 	in.VolumeMounts != nil {
			out[i]["volume_mounts"] = flattenVolumeMountSpecSlice(in.VolumeMounts)
		}

		if 	in.Volumes != nil {
			out[i]["volumes"] = flattenVolumeSpecSlice(in.Volumes)
		}

		if 	in.Zones != nil {
			out[i]["zones"] = flattenStringSlice(in.Zones)
		}
	}

	return out
}

func flattenLoadBalancerSlice(in []kops.LoadBalancer) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	*in[i].LoadBalancerName != "" {
			out[i]["load_balancer_name"] = flattenString(*in[i].LoadBalancerName)
		}

		if 	*in[i].TargetGroupARN != "" {
			out[i]["target_group_arn"] = flattenString(*in[i].TargetGroupARN)
		}
	}

	return out
}

func flattenMixedInstancesPolicySpec(in *kops.MixedInstancesPolicySpec) []map[string]interface{} {
	out := make([]map[string]interface{}, 1)

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in.Instances != nil {
			out[i]["instances"] = flattenStringSlice(in.Instances)
		}

		if 	*in.OnDemandAboveBase != 0 {
			out[i]["on_demand_above_base"] = flattenInt64(*in.OnDemandAboveBase)
		}

		if 	*in.OnDemandAllocationStrategy != "" {
			out[i]["on_demand_allocation_strategy"] = flattenString(*in.OnDemandAllocationStrategy)
		}

		if 	*in.OnDemandBase != 0 {
			out[i]["on_demand_base"] = flattenInt64(*in.OnDemandBase)
		}

		if 	*in.SpotAllocationStrategy != "" {
			out[i]["spot_allocation_strategy"] = flattenString(*in.SpotAllocationStrategy)
		}

		if 	*in.SpotInstancePools != 0 {
			out[i]["spot_instance_pools"] = flattenInt64(*in.SpotInstancePools)
		}
	}

	return out
}

func flattenUserDataSlice(in []kops.UserData) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Content != "" {
			out[i]["content"] = flattenString(in[i].Content)
		}

		if 	in[i].Name != "" {
			out[i]["name"] = flattenString(in[i].Name)
		}

		if 	in[i].Type != "" {
			out[i]["type"] = flattenString(in[i].Type)
		}
	}

	return out
}

func flattenVolumeMountSpecSlice(in []*kops.VolumeMountSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Device != "" {
			out[i]["device"] = flattenString(in[i].Device)
		}

		if 	in[i].Filesystem != "" {
			out[i]["filesystem"] = flattenString(in[i].Filesystem)
		}

		if 	in[i].FormatOptions != nil {
			out[i]["format_options"] = flattenStringSlice(in[i].FormatOptions)
		}

		if 	in[i].MountOptions != nil {
			out[i]["mount_options"] = flattenStringSlice(in[i].MountOptions)
		}

		if 	in[i].Path != "" {
			out[i]["path"] = flattenString(in[i].Path)
		}
	}

	return out
}

func flattenVolumeSpecSlice(in []*kops.VolumeSpec) []map[string]interface{} {
	out := make([]map[string]interface{}, len(in))

	for i := 0; i < len(out); i++ {
		out[i] = make(map[string]interface{})

		if 	in[i].Device != "" {
			out[i]["device"] = flattenString(in[i].Device)
		}

		if 	*in[i].Encrypted {
			out[i]["encrypted"] = flattenBool(in[i].Encrypted)
		}

		if 	*in[i].Iops != 0 {
			out[i]["iops"] = flattenInt64(*in[i].Iops)
		}

		if 	in[i].Size != 0 {
			out[i]["size"] = flattenInt64(in[i].Size)
		}

		if 	in[i].Type != "" {
			out[i]["type"] = flattenString(in[i].Type)
		}
	}

	return out
}
