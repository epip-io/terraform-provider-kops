// Code generated by engine.go; DO NOT EDIT.

package provider

import (
	"github.com/hashicorp/terraform/helper/schema"
	// "github.com/hashicorp/terraform/helper/validation"
)

func resourceCluster() *schema.Resource {
	return &schema.Resource{
		Create: resourceClusterCreate,
		Read:   resourceClusterRead,
		Update: resourceClusterUpdate,
		Delete: resourceClusterDelete,
		Exists: resourceClusterExists,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"api_version": schemaOptionalString(),
			"kind": schemaOptionalString(),
			"metadata": schemaObjectMeta(),
			"spec": schemaClusterSpec(),
		},
	}
}

func datasourceCluster() *schema.Resource {
	return &schema.Resource{
		Read: resourceClusterRead,
		Importer: &schema.ResourceImporter{
			State: schema.ImportStatePassthrough,
		},
		Schema: map[string]*schema.Schema{
			"api_version": schemaOptionalString(),
			"kind": schemaOptionalString(),
			"metadata": schemaObjectMeta(),
			"spec": schemaClusterSpec(),
		},
	}
}

func schemaAccessSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"dns": schemaDNSAccessSpec(),
				"load_balancer": schemaLoadBalancerAccessSpec(),
			},
		},
	}
}

func schemaAddonSpecSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"manifest": schemaOptionalString(),
			},
		},
	}
}

func schemaAlwaysAllowAuthorizationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaAmazonVPCNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"image_name": schemaOptionalString(),
			},
		},
	}
}

func schemaAssets() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"container_proxy": schemaOptionalString(),
				"container_registry": schemaOptionalString(),
				"file_repository": schemaOptionalString(),
			},
		},
	}
}

func schemaAuthenticationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"aws": schemaAwsAuthenticationSpec(),
				"kopeio": schemaKopeioAuthenticationSpec(),
			},
		},
	}
}

func schemaAuthorizationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"always_allow": schemaAlwaysAllowAuthorizationSpec(),
				"rbac": schemaRBACAuthorizationSpec(),
			},
		},
	}
}

func schemaAwsAuthenticationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"cpu_limit": schemaQuantity(),
				"cpu_request": schemaQuantity(),
				"image": schemaOptionalString(),
				"memory_limit": schemaQuantity(),
				"memory_request": schemaQuantity(),
			},
		},
	}
}

func schemaBastionSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bastion_public_name": schemaOptionalString(),
				"idle_timeout_seconds": schemaOptionalFloat(),
			},
		},
	}
}

func schemaCNINetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"uses_secondary_ip": schemaOptionalBool(),
			},
		},
	}
}

func schemaCalicoNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"cross_subnet": schemaOptionalBool(),
				"ipip_mode": schemaOptionalString(),
				"log_severity_screen": schemaOptionalString(),
				"mtu": schemaOptionalInt(),
				"major_version": schemaOptionalString(),
				"prometheus_go_metrics_enabled": schemaOptionalBool(),
				"prometheus_metrics_enabled": schemaOptionalBool(),
				"prometheus_metrics_port": schemaOptionalInt(),
				"prometheus_process_metrics_enabled": schemaOptionalBool(),
				"typha_prometheus_metrics_enabled": schemaOptionalBool(),
				"typha_prometheus_metrics_port": schemaOptionalInt(),
				"typha_replicas": schemaOptionalInt(),
			},
		},
	}
}

func schemaCanalNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"chain_insert_mode": schemaOptionalString(),
				"default_endpoint_to_host_action": schemaOptionalString(),
				"disable_flannel_forward_rules": schemaOptionalBool(),
				"log_severity_sys": schemaOptionalString(),
				"mtu": schemaOptionalInt(),
				"prometheus_go_metrics_enabled": schemaOptionalBool(),
				"prometheus_metrics_enabled": schemaOptionalBool(),
				"prometheus_metrics_port": schemaOptionalInt(),
				"prometheus_process_metrics_enabled": schemaOptionalBool(),
			},
		},
	}
}

func schemaCiliumNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"access_log": schemaOptionalString(),
				"agent_labels": schemaOptionalStringSlice(),
				"allow_localhost": schemaOptionalString(),
				"auto_direct_node_routes": schemaRequiredBool(),
				"auto_ipv_6node_routes": schemaOptionalBool(),
				"bpf_ct_global_any_max": schemaRequiredInt(),
				"bpf_ct_global_tcp_max": schemaRequiredInt(),
				"bpf_root": schemaOptionalString(),
				"cluster_name": schemaRequiredString(),
				"cni_bin_path": schemaRequiredString(),
				"container_runtime": schemaOptionalStringSlice(),
				"container_runtime_endpoint": schemaOptionalStringMap(),
				"container_runtime_labels": schemaOptionalString(),
				"debug": schemaOptionalBool(),
				"debug_verbose": schemaOptionalStringSlice(),
				"device": schemaOptionalString(),
				"disable_conntrack": schemaOptionalBool(),
				"disable_ipv_4": schemaOptionalBool(),
				"disable_k8s_services": schemaOptionalBool(),
				"disable_masquerade": schemaOptionalBool(),
				"enableipv_4": schemaRequiredBool(),
				"enableipv_6": schemaRequiredBool(),
				"enable_node_port": schemaRequiredBool(),
				"enable_policy": schemaOptionalString(),
				"enable_tracing": schemaOptionalBool(),
				"envoy_log": schemaOptionalString(),
				"ip_tables_rules_noinstall": schemaRequiredBool(),
				"ipv_4cluster_cidr_mask_size": schemaOptionalInt(),
				"ipv_4node": schemaOptionalString(),
				"ipv_4range": schemaOptionalString(),
				"ipv_4service_range": schemaOptionalString(),
				"ipv_6cluster_alloc_cidr": schemaOptionalString(),
				"ipv_6node": schemaOptionalString(),
				"ipv_6range": schemaOptionalString(),
				"ipv_6service_range": schemaOptionalString(),
				"k_8s_api_server": schemaOptionalString(),
				"k_8s_kubeconfig_path": schemaOptionalString(),
				"keep_bpf_templates": schemaOptionalBool(),
				"keep_config": schemaOptionalBool(),
				"lb": schemaOptionalString(),
				"label_prefix_file": schemaOptionalString(),
				"labels": schemaOptionalStringSlice(),
				"lib_dir": schemaOptionalString(),
				"log_driver": schemaOptionalStringSlice(),
				"log_opt": schemaOptionalStringMap(),
				"logstash": schemaOptionalBool(),
				"logstash_agent": schemaOptionalString(),
				"logstash_probe_timer": schemaOptionalUint32(),
				"monitor_aggregation": schemaRequiredString(),
				"nat_46range": schemaOptionalString(),
				"node_init_bootstrap_file": schemaRequiredString(),
				"pprof": schemaOptionalBool(),
				"preallocate_bpf_maps": schemaRequiredBool(),
				"prefilter_device": schemaOptionalString(),
				"prometheus_serve_addr": schemaOptionalString(),
				"reconfigure_kubelet": schemaRequiredBool(),
				"remove_cbr_bridge": schemaRequiredBool(),
				"restart_pods": schemaRequiredBool(),
				"restore": schemaOptionalBool(),
				"sidecar_istio_proxy_image": schemaRequiredString(),
				"single_cluster_route": schemaOptionalBool(),
				"socket_path": schemaOptionalString(),
				"state_dir": schemaOptionalString(),
				"to_fqdns_enable_poller": schemaRequiredBool(),
				"trace_payloadlen": schemaOptionalInt(),
				"tunnel": schemaOptionalString(),
				"version": schemaOptionalString(),
			},
		},
	}
}

func schemaClassicNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaCloudConfiguration() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"disable_security_group_ingress": schemaOptionalBool(),
				"elb_security_group": schemaOptionalString(),
				"multizone": schemaOptionalBool(),
				"node_instance_prefix": schemaOptionalString(),
				"node_tags": schemaOptionalString(),
				"openstack": schemaOpenstackConfiguration(),
				"spotinst_orientation": schemaOptionalString(),
				"spotinst_product": schemaOptionalString(),
				"v_sphere_core_dns_server": schemaOptionalString(),
				"v_sphere_datacenter": schemaOptionalString(),
				"v_sphere_datastore": schemaOptionalString(),
				"v_sphere_password": schemaOptionalString(),
				"v_sphere_resource_pool": schemaOptionalString(),
				"v_sphere_server": schemaOptionalString(),
				"v_sphere_username": schemaOptionalString(),
			},
		},
	}
}

func schemaCloudControllerManagerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"allocate_node_cid_rss": schemaOptionalBool(),
				"cidr_allocator_type": schemaOptionalString(),
				"cloud_provider": schemaOptionalString(),
				"cluster_cidr": schemaOptionalString(),
				"cluster_name": schemaOptionalString(),
				"configure_cloud_routes": schemaOptionalBool(),
				"image": schemaOptionalString(),
				"leader_election": schemaLeaderElectionConfiguration(),
				"log_level": schemaOptionalInt(),
				"master": schemaOptionalString(),
				"use_service_account_credentials": schemaOptionalBool(),
			},
		},
	}
}

func schemaClusterSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"api": schemaAccessSpec(),
				"additional_network_cid_rss": schemaOptionalStringSlice(),
				"additional_policies": schemaOptionalStringMap(),
				"additional_sans": schemaOptionalStringSlice(),
				"addons": schemaAddonSpecSlice(),
				"assets": schemaAssets(),
				"authentication": schemaAuthenticationSpec(),
				"authorization": schemaAuthorizationSpec(),
				"channel": schemaOptionalString(),
				"cloud_config": schemaCloudConfiguration(),
				"cloud_labels": schemaOptionalStringMap(),
				"cloud_provider": schemaOptionalString(),
				"cluster_dns_domain": schemaOptionalString(),
				"config_base": schemaOptionalString(),
				"config_store": schemaOptionalString(),
				"dns_zone": schemaOptionalString(),
				"disable_subnet_tags": schemaOptionalBool(),
				"docker": schemaDockerConfig(),
				"egress_proxy": schemaEgressProxySpec(),
				"encryption_config": schemaOptionalBool(),
				"etcd_clusters": schemaEtcdClusterSpecSlice(),
				"cloud_controller_manager": schemaCloudControllerManagerConfig(),
				"external_dns": schemaExternalDNSConfig(),
				"file_assets": schemaFileAssetSpecSlice(),
				"hooks": schemaHookSpecSlice(),
				"iam": schemaIAMSpec(),
				"isolate_masters": schemaOptionalBool(),
				"key_store": schemaOptionalString(),
				"kube_api_server": schemaKubeAPIServerConfig(),
				"kube_controller_manager": schemaKubeControllerManagerConfig(),
				"kube_dns": schemaKubeDNSConfig(),
				"kube_proxy": schemaKubeProxyConfig(),
				"kube_scheduler": schemaKubeSchedulerConfig(),
				"kubelet": schemaKubeletConfigSpec(),
				"kubernetes_api_access": schemaOptionalStringSlice(),
				"kubernetes_version": schemaOptionalString(),
				"master_internal_name": schemaOptionalString(),
				"master_kubelet": schemaKubeletConfigSpec(),
				"master_public_name": schemaOptionalString(),
				"network_cidr": schemaOptionalString(),
				"network_id": schemaOptionalString(),
				"networking": schemaNetworkingSpec(),
				"node_authorization": schemaNodeAuthorizationSpec(),
				"node_port_access": schemaOptionalStringSlice(),
				"non_masquerade_cidr": schemaOptionalString(),
				"pod_cidr": schemaOptionalString(),
				"project": schemaOptionalString(),
				"ssh_access": schemaOptionalStringSlice(),
				"ssh_key_name": schemaOptionalString(),
				"secret_store": schemaOptionalString(),
				"service_cluster_ip_range": schemaOptionalString(),
				"subnets": schemaClusterSubnetSpecSlice(),
				"target": schemaTargetSpec(),
				"topology": schemaTopologySpec(),
				"update_policy": schemaOptionalString(),
			},
		},
	}
}

func schemaClusterSubnetSpecSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"cidr": schemaOptionalString(),
				"egress": schemaOptionalString(),
				"name": schemaOptionalString(),
				"id": schemaOptionalString(),
				"public_ip": schemaOptionalString(),
				"region": schemaOptionalString(),
				"type": schemaOptionalSubnetType(),
				"zone": schemaOptionalString(),
			},
		},
	}
}

func schemaDNSAccessSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaDNSSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"type": schemaOptionalDNSType(),
			},
		},
	}
}

func schemaDockerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"authorization_plugins": schemaOptionalStringSlice(),
				"bridge": schemaOptionalString(),
				"bridge_ip": schemaOptionalString(),
				"data_root": schemaOptionalString(),
				"default_ulimit": schemaOptionalStringSlice(),
				"exec_opt": schemaOptionalStringSlice(),
				"exec_root": schemaOptionalString(),
				"experimental": schemaOptionalBool(),
				"hosts": schemaOptionalStringSlice(),
				"ip_masq": schemaOptionalBool(),
				"ip_tables": schemaOptionalBool(),
				"insecure_registries": schemaOptionalStringSlice(),
				"insecure_registry": schemaOptionalString(),
				"live_restore": schemaOptionalBool(),
				"log_driver": schemaOptionalString(),
				"log_level": schemaOptionalString(),
				"log_opt": schemaOptionalStringSlice(),
				"mtu": schemaOptionalInt(),
				"metrics_address": schemaOptionalString(),
				"registry_mirrors": schemaOptionalStringSlice(),
				"skip_install": schemaOptionalBool(),
				"storage": schemaOptionalString(),
				"storage_opts": schemaOptionalStringSlice(),
				"user_namespace_remap": schemaOptionalString(),
				"version": schemaOptionalString(),
			},
		},
	}
}

func schemaDuration() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
			},
		},
	}
}

func schemaEgressProxySpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"http_proxy": schemaHTTPProxy(),
				"excludes": schemaOptionalString(),
			},
		},
	}
}

func schemaEtcdBackupSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"backup_store": schemaOptionalString(),
				"image": schemaOptionalString(),
			},
		},
	}
}

func schemaEtcdClusterSpecSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"backups": schemaEtcdBackupSpec(),
				"cpu_request": schemaQuantity(),
				"enable_etcd_tls": schemaOptionalBool(),
				"enable_tls_auth": schemaOptionalBool(),
				"heartbeat_interval": schemaDuration(),
				"image": schemaOptionalString(),
				"leader_election_timeout": schemaDuration(),
				"manager": schemaEtcdManagerSpec(),
				"etcd_members": schemaEtcdMemberSpecSlice(),
				"memory_request": schemaQuantity(),
				"name": schemaOptionalString(),
				"provider": schemaOptionalEtcdProviderType(),
				"version": schemaOptionalString(),
			},
		},
	}
}

func schemaEtcdManagerSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"image": schemaOptionalString(),
			},
		},
	}
}

func schemaEtcdMemberSpecSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"encrypted_volume": schemaOptionalBool(),
				"instance_group": schemaOptionalString(),
				"kms_key_id": schemaOptionalString(),
				"name": schemaOptionalString(),
				"volume_iops": schemaOptionalInt(),
				"volume_size": schemaOptionalInt(),
				"volume_type": schemaOptionalString(),
			},
		},
	}
}

func schemaExecContainerAction() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"command": schemaOptionalStringSlice(),
				"environment": schemaOptionalStringMap(),
				"image": schemaOptionalString(),
			},
		},
	}
}

func schemaExternalDNSConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"disable": schemaOptionalBool(),
				"watch_ingress": schemaOptionalBool(),
				"watch_namespace": schemaOptionalString(),
			},
		},
	}
}

func schemaExternalNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaFields() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
			},
		},
	}
}

func schemaFlannelNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"backend": schemaOptionalString(),
				"iptables_resync_seconds": schemaOptionalInt(),
			},
		},
	}
}

func schemaGCENetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaHTTPProxy() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"host": schemaOptionalString(),
				"port": schemaOptionalInt(),
			},
		},
	}
}

func schemaIAMSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"allow_container_registry": schemaOptionalBool(),
				"legacy": schemaRequiredBool(),
			},
		},
	}
}

func schemaInitializerSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Required: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"name": schemaRequiredString(),
			},
		},
	}
}

func schemaKopeioAuthenticationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaKopeioNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaKubeAPIServerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"api_audiences": schemaOptionalStringSlice(),
				"api_server_count": schemaOptionalInt(),
				"address": schemaOptionalString(),
				"admission_control": schemaOptionalStringSlice(),
				"admission_control_config_file": schemaOptionalString(),
				"allow_privileged": schemaOptionalBool(),
				"anonymous_auth": schemaOptionalBool(),
				"append_admission_plugins": schemaOptionalStringSlice(),
				"audit_log_format": schemaOptionalString(),
				"audit_log_max_age": schemaOptionalInt(),
				"audit_log_max_backups": schemaOptionalInt(),
				"audit_log_max_size": schemaOptionalInt(),
				"audit_log_path": schemaOptionalString(),
				"audit_policy_file": schemaOptionalString(),
				"audit_webhook_batch_buffer_size": schemaOptionalInt(),
				"audit_webhook_batch_max_size": schemaOptionalInt(),
				"audit_webhook_batch_max_wait": schemaDuration(),
				"audit_webhook_batch_throttle_burst": schemaOptionalInt(),
				"audit_webhook_batch_throttle_enable": schemaOptionalBool(),
				"audit_webhook_batch_throttle_qps": schemaOptionalFloat(),
				"audit_webhook_config_file": schemaOptionalString(),
				"audit_webhook_initial_backoff": schemaDuration(),
				"audit_webhook_mode": schemaOptionalString(),
				"authentication_token_webhook_cache_ttl": schemaDuration(),
				"authentication_token_webhook_config_file": schemaOptionalString(),
				"authorization_mode": schemaOptionalString(),
				"authorization_rbac_super_user": schemaOptionalString(),
				"authorization_webhook_cache_authorized_ttl": schemaDuration(),
				"authorization_webhook_cache_unauthorized_ttl": schemaDuration(),
				"authorization_webhook_config_file": schemaOptionalString(),
				"basic_auth_file": schemaOptionalString(),
				"bind_address": schemaOptionalString(),
				"cpu_request": schemaOptionalString(),
				"client_ca_file": schemaOptionalString(),
				"cloud_provider": schemaOptionalString(),
				"disable_admission_plugins": schemaOptionalStringSlice(),
				"disable_basic_auth": schemaOptionalBool(),
				"enable_admission_plugins": schemaOptionalStringSlice(),
				"enable_aggregator_routing": schemaOptionalBool(),
				"enable_bootstrap_token_auth": schemaOptionalBool(),
				"etcd_ca_file": schemaOptionalString(),
				"etcd_cert_file": schemaOptionalString(),
				"etcd_key_file": schemaOptionalString(),
				"etcd_quorum_read": schemaOptionalBool(),
				"etcd_servers": schemaOptionalStringSlice(),
				"etcd_servers_overrides": schemaOptionalStringSlice(),
				"event_ttl": schemaDuration(),
				"experimental_encryption_provider_config": schemaOptionalString(),
				"feature_gates": schemaOptionalStringMap(),
				"http_2max_streams_per_connection": schemaOptionalInt(),
				"image": schemaOptionalString(),
				"insecure_bind_address": schemaOptionalString(),
				"insecure_port": schemaOptionalInt(),
				"kubelet_client_certificate": schemaOptionalString(),
				"kubelet_client_key": schemaOptionalString(),
				"kubelet_preferred_address_types": schemaOptionalStringSlice(),
				"log_level": schemaOptionalInt(),
				"max_mutating_requests_inflight": schemaOptionalInt(),
				"max_requests_inflight": schemaOptionalInt(),
				"min_request_timeout": schemaOptionalInt(),
				"oidc_ca_file": schemaOptionalString(),
				"oidc_client_id": schemaOptionalString(),
				"oidc_groups_claim": schemaOptionalString(),
				"oidc_groups_prefix": schemaOptionalString(),
				"oidc_issuer_url": schemaOptionalString(),
				"oidc_required_claim": schemaOptionalStringSlice(),
				"oidc_username_claim": schemaOptionalString(),
				"oidc_username_prefix": schemaOptionalString(),
				"proxy_client_cert_file": schemaOptionalString(),
				"proxy_client_key_file": schemaOptionalString(),
				"requestheader_allowed_names": schemaOptionalStringSlice(),
				"requestheader_client_ca_file": schemaOptionalString(),
				"requestheader_extra_header_prefixes": schemaOptionalStringSlice(),
				"requestheader_group_headers": schemaOptionalStringSlice(),
				"requestheader_username_headers": schemaOptionalStringSlice(),
				"runtime_config": schemaOptionalStringMap(),
				"secure_port": schemaOptionalInt(),
				"service_account_issuer": schemaOptionalString(),
				"service_account_key_file": schemaOptionalStringSlice(),
				"service_account_signing_key_file": schemaOptionalString(),
				"service_cluster_ip_range": schemaOptionalString(),
				"service_node_port_range": schemaOptionalString(),
				"storage_backend": schemaOptionalString(),
				"tls_cert_file": schemaOptionalString(),
				"tls_cipher_suites": schemaOptionalStringSlice(),
				"tls_min_version": schemaOptionalString(),
				"tls_private_key_file": schemaOptionalString(),
				"target_ram_mb": schemaOptionalInt(),
				"token_auth_file": schemaOptionalString(),
			},
		},
	}
}

func schemaKubeControllerManagerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"allocate_node_cid_rss": schemaOptionalBool(),
				"attach_detach_reconcile_sync_period": schemaDuration(),
				"cidr_allocator_type": schemaOptionalString(),
				"cloud_provider": schemaOptionalString(),
				"cluster_cidr": schemaOptionalString(),
				"cluster_name": schemaOptionalString(),
				"configure_cloud_routes": schemaOptionalBool(),
				"controllers": schemaOptionalStringSlice(),
				"experimental_cluster_signing_duration": schemaDuration(),
				"feature_gates": schemaOptionalStringMap(),
				"horizontal_pod_autoscaler_downscale_delay": schemaDuration(),
				"horizontal_pod_autoscaler_downscale_stabilization": schemaDuration(),
				"horizontal_pod_autoscaler_sync_period": schemaDuration(),
				"horizontal_pod_autoscaler_tolerance": schemaOptionalFloat(),
				"horizontal_pod_autoscaler_upscale_delay": schemaDuration(),
				"horizontal_pod_autoscaler_use_rest_clients": schemaOptionalBool(),
				"image": schemaOptionalString(),
				"kube_api_burst": schemaOptionalInt(),
				"kube_apiqps": schemaOptionalFloat(),
				"leader_election": schemaLeaderElectionConfiguration(),
				"log_level": schemaOptionalInt(),
				"master": schemaOptionalString(),
				"min_resync_period": schemaOptionalString(),
				"node_cidr_mask_size": schemaOptionalInt(),
				"node_monitor_grace_period": schemaDuration(),
				"node_monitor_period": schemaDuration(),
				"pod_eviction_timeout": schemaDuration(),
				"root_ca_file": schemaOptionalString(),
				"service_account_private_key_file": schemaOptionalString(),
				"tls_cipher_suites": schemaOptionalStringSlice(),
				"tls_min_version": schemaOptionalString(),
				"terminated_pod_gc_threshold": schemaOptionalInt(),
				"use_service_account_credentials": schemaOptionalBool(),
			},
		},
	}
}

func schemaKubeDNSConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"cpu_request": schemaQuantity(),
				"cache_max_concurrent": schemaOptionalInt(),
				"cache_max_size": schemaOptionalInt(),
				"domain": schemaOptionalString(),
				"external_core_file": schemaOptionalString(),
				"image": schemaOptionalString(),
				"memory_limit": schemaQuantity(),
				"memory_request": schemaQuantity(),
				"provider": schemaOptionalString(),
				"replicas": schemaOptionalInt(),
				"server_ip": schemaOptionalString(),
				"stub_domains": schemaOptionalStringSliceMap(),
				"upstream_nameservers": schemaOptionalStringSlice(),
			},
		},
	}
}

func schemaKubeProxyConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bind_address": schemaOptionalString(),
				"cpu_limit": schemaOptionalString(),
				"cpu_request": schemaOptionalString(),
				"cluster_cidr": schemaOptionalString(),
				"conntrack_max_per_core": schemaOptionalInt(),
				"conntrack_min": schemaOptionalInt(),
				"enabled": schemaOptionalBool(),
				"feature_gates": schemaOptionalStringMap(),
				"hostname_override": schemaOptionalString(),
				"ipvs_exclude_cidrs": schemaOptionalStringSlice(),
				"ipvs_min_sync_period": schemaDuration(),
				"ipvs_scheduler": schemaOptionalString(),
				"ipvs_sync_period": schemaDuration(),
				"image": schemaOptionalString(),
				"log_level": schemaOptionalInt(),
				"master": schemaOptionalString(),
				"memory_limit": schemaOptionalString(),
				"memory_request": schemaOptionalString(),
				"metrics_bind_address": schemaOptionalString(),
				"proxy_mode": schemaOptionalString(),
			},
		},
	}
}

func schemaKubeSchedulerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"feature_gates": schemaOptionalStringMap(),
				"image": schemaOptionalString(),
				"leader_election": schemaLeaderElectionConfiguration(),
				"log_level": schemaOptionalInt(),
				"master": schemaOptionalString(),
				"max_persistent_volumes": schemaOptionalInt(),
				"use_policy_config_map": schemaOptionalBool(),
			},
		},
	}
}

func schemaKubenetNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaKuberouterNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaLeaderElectionConfiguration() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"leader_elect": schemaOptionalBool(),
			},
		},
	}
}

func schemaListMeta() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"continue": schemaOptionalString(),
				"remaining_item_count": schemaOptionalFloat(),
				"resource_version": schemaOptionalString(),
				"self_link": schemaOptionalString(),
			},
		},
	}
}

func schemaLoadBalancerAccessSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"additional_security_groups": schemaOptionalStringSlice(),
				"cross_zone_load_balancing": schemaOptionalBool(),
				"idle_timeout_seconds": schemaOptionalFloat(),
				"ssl_certificate": schemaOptionalString(),
				"security_group_override": schemaOptionalString(),
				"type": schemaOptionalLoadBalancerType(),
				"use_for_internal_api": schemaOptionalBool(),
			},
		},
	}
}

func schemaLyftVPCNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"subnet_tags": schemaOptionalStringMap(),
			},
		},
	}
}

func schemaNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"amazonvpc": schemaAmazonVPCNetworkingSpec(),
				"cni": schemaCNINetworkingSpec(),
				"calico": schemaCalicoNetworkingSpec(),
				"canal": schemaCanalNetworkingSpec(),
				"cilium": schemaCiliumNetworkingSpec(),
				"classic": schemaClassicNetworkingSpec(),
				"external": schemaExternalNetworkingSpec(),
				"flannel": schemaFlannelNetworkingSpec(),
				"gce": schemaGCENetworkingSpec(),
				"kopeio": schemaKopeioNetworkingSpec(),
				"kubenet": schemaKubenetNetworkingSpec(),
				"kuberouter": schemaKuberouterNetworkingSpec(),
				"lyftvpc": schemaLyftVPCNetworkingSpec(),
				"romana": schemaRomanaNetworkingSpec(),
				"weave": schemaWeaveNetworkingSpec(),
			},
		},
	}
}

func schemaNodeAuthorizationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"node_authorizer": schemaNodeAuthorizerSpec(),
			},
		},
	}
}

func schemaNodeAuthorizerSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"authorizer": schemaOptionalString(),
				"features": schemaOptionalStringSlice(),
				"image": schemaOptionalString(),
				"interval": schemaDuration(),
				"node_url": schemaOptionalString(),
				"port": schemaOptionalInt(),
				"timeout": schemaDuration(),
				"token_ttl": schemaDuration(),
			},
		},
	}
}

func schemaOpenstackBlockStorageConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"ignore_volume_az": schemaOptionalBool(),
				"override_volume_az": schemaOptionalString(),
				"bs_version": schemaOptionalString(),
			},
		},
	}
}

func schemaOpenstackConfiguration() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"block_storage": schemaOpenstackBlockStorageConfig(),
				"insecure_skip_verify": schemaOptionalBool(),
				"loadbalancer": schemaOpenstackLoadbalancerConfig(),
				"monitor": schemaOpenstackMonitor(),
				"router": schemaOpenstackRouter(),
			},
		},
	}
}

func schemaOpenstackLoadbalancerConfig() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"floating_network": schemaOptionalString(),
				"floating_network_id": schemaOptionalString(),
				"floating_subnet": schemaOptionalString(),
				"manage_security_groups": schemaOptionalBool(),
				"method": schemaOptionalString(),
				"provider": schemaOptionalString(),
				"subnet_id": schemaOptionalString(),
				"use_octavia": schemaOptionalBool(),
			},
		},
	}
}

func schemaOpenstackMonitor() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"delay": schemaOptionalString(),
				"max_retries": schemaOptionalInt(),
				"timeout": schemaOptionalString(),
			},
		},
	}
}

func schemaOpenstackRouter() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"dns_servers": schemaOptionalString(),
				"external_network": schemaOptionalString(),
				"external_subnet": schemaOptionalString(),
			},
		},
	}
}

func schemaOptionalCauseType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalDNSType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalEtcdProviderType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalInstanceGroupRoleSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
	}
}

func schemaOptionalLoadBalancerType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalManagedFieldsOperationType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalStatusReason() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalStringSliceMap() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeMap,
		Optional: true,
	}
}

func schemaOptionalSubnetType() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Optional: true,
	}
}

func schemaOptionalUint32() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeFloat,
		Optional: true,
	}
}

func schemaQuantity() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
			},
		},
	}
}

func schemaRBACAuthorizationSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
	}
}

func schemaRequiredBool() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeBool,
		Required: true,
	}
}

func schemaRequiredInt() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeInt,
		Required: true,
	}
}

func schemaRequiredString() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Required: true,
	}
}

func schemaRequiredUID() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeString,
		Required: true,
	}
}

func schemaRomanaNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"daemon_service_ip": schemaOptionalString(),
				"etcd_service_ip": schemaOptionalString(),
			},
		},
	}
}

func schemaStatus() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"code": schemaOptionalInt(),
				"details": schemaStatusDetails(),
				"metadata": schemaListMeta(),
				"message": schemaOptionalString(),
				"reason": schemaOptionalStatusReason(),
				"status": schemaOptionalString(),
			},
		},
	}
}

func schemaStatusCauseSlice() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"field": schemaOptionalString(),
				"message": schemaOptionalString(),
				"reason": schemaOptionalCauseType(),
			},
		},
	}
}

func schemaStatusDetails() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"causes": schemaStatusCauseSlice(),
				"group": schemaOptionalString(),
				"kind": schemaOptionalString(),
				"name": schemaOptionalString(),
				"retry_after_seconds": schemaOptionalInt(),
				"uid": schemaOptionalUID(),
			},
		},
	}
}

func schemaTargetSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"terraform": schemaTerraformSpec(),
			},
		},
	}
}

func schemaTerraformSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"provider_extra_config": schemaOptionalStringMap(),
			},
		},
	}
}

func schemaTopologySpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bastion": schemaBastionSpec(),
				"dns": schemaDNSSpec(),
				"masters": schemaOptionalString(),
				"nodes": schemaOptionalString(),
			},
		},
	}
}

func schemaWeaveNetworkingSpec() *schema.Schema {
	return &schema.Schema{
		Type: schema.TypeList,
		MaxItems: 1,
		Optional: true,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"conn_limit": schemaOptionalInt(),
				"mtu": schemaOptionalInt(),
				"net_extra_args": schemaOptionalString(),
				"no_masq_local": schemaOptionalInt(),
			},
		},
	}
}